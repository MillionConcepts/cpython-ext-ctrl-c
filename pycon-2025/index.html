<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no">
    <title>Writing Extension Modules to be Interruptible</title>
    <link rel="stylesheet" href="rjs/theme-mc-sol-dark.css">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <div class="l-title-card">
            <h1>Writing Extension Modules<br>to be Interruptible</h1>
            <div class="author-card">
              <img src="picassohead-me.svg" width="240" height="240"
                   alt="An abstract representation of my head, in profile">
              <div class="author-handles">
                <p><strong>Zack Weinberg</strong></p>
                <p>〈<code class="email">zack@millionconcepts.com</code>〉</p>
                <p>〈<code class="email">zack@owlfolio.org</code>〉</p>
                <p><a href="https://www.owlfolio.org"><code>https://www.owlfolio.org/</code></a></p>
              </div>
            </div>
            <div class="logos">
              <a class="employer" href="https://millionconcepts.com/"><img src="MC-logo.svg" alt="Million Concepts LLC" height="70"></a>
              <a class="venue" href="https://us.pycon.org/2025/"><img src="pycon-2025-us-logo.svg" alt="PyCon US 2025" height="100"></a>
            </div>
            <p class="footnote">If you’re reading this slide deck on
            the web, press S to bring up my notes.</p>
          </div>
          <aside class="notes">
            Hi, I’m Zack Weinberg and I’m here to talk about making
            extension modules interruptible—why that’s a thing you
            have to do by hand, and how to do it, and how to do
            it <em>efficiently</em>, and finally how we might change
            some things to make it easier.
          </aside>
        </section>
        <section>
          <h2>A Common Bug</h2>
          <p>(in compiled extension modules)</p>
          <pre class="language-python-repl short-example"
><span class="fragment semi-fade-out" data-fragment-index="1"><span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword h-namespace">import</span> <span class="h-name h-namespace">numpy</span> <span class="h-keyword">as</span> <span class="h-name h-namespace">np</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-variable">rng</span> <span class="h-operator">=</span> <span class="h-name">np</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-operator">.</span><span class="h-name">default_rng</span><span class="h-delim">()</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword">def</span> <span class="h-defun">g</span><span class="h-delim">(</span><span class="h-variable">n</span><span class="h-operator">=</span><span class="h-number h-integer">1000000000</span><span class="h-delim">):</span>
<span class="h-prompt">... </span>    <span class="h-keyword">return</span> <span class="h-name">rng</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-delim">(</span><span class="h-name">n</span><span class="h-delim">)</span>
</span><span class="fragment" data-fragment-index="1"><span class="h-prompt">...</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-name">g</span><span class="h-delim">()</span>
</span><span class="h-output fragment" data-fragment-index="2">^C</span
><span class="fragment" data-fragment-index="3"><span class="h-traceback">Traceback (most recent call last):
  File <span class="h-name h-builtin">&quot;&lt;stdin&gt;&quot;</span>, line <span class="h-number">1</span>, in <span class="h-name">&lt;module&gt;</span>
  File <span class="h-name h-builtin">&quot;&lt;stdin&gt;&quot;</span>, line <span class="h-number">2</span>, in <span class="h-name">g</span>
<span class="h-name h-class">KeyboardInterrupt</span></span>
<span class="h-prompt">&gt;&gt;&gt;</span></span></pre>
          <p class="fragment" data-fragment-index="3"><span class="r-frame">&nbsp;3.5 second delay&nbsp;</span></p>
          <aside class="notes">
            Let’s start with the problem.
            If you’ve used Python for interactive number crunching,
            there’s a good chance you’ve seen this bug.
            You set up a long calculation.  To demonstrate, I’m just
            gonna generate a whole lot of random numbers, using NumPy.
            <p>
              I run the function…
            <p>
              … and immediately realize that I forgot to store the
              result in a variable, so I hit control-C …
            <p>
              … and I have to wait three and a half seconds to get the
              prompt back.
            <p>
              It can be <em>minutes</em> if your calculation is big
              enough.  And all that CPU time is just <em>wasted</em>.
          </aside>
        </section>
        <section>
          <h2>What went wrong</h2>
          <ul>
            <li>NumPy didn’t ever call <code>PyErr_CheckSignals</code></li>
            <li>Common bug in compiled-code extensions</li>
            <li class="fragment fade-up">This talk is about:
              <ol>
                <li>Why there’s no way to avoid needing to do this</li>
                <li>Why, today, many extensions <i>don’t</i> do this</li>
                <li>How we can make it easier to do this</li>
              </ol></li>
          </ul>
          <aside class="notes">
            Short version of what went wrong:
            NumPy’s “fill array with random numbers” loop never
            called <code>PyErr_CheckSignals</code>.
            <p>
              I’m not here to pick on NumPy specifically.
              Lots of compiled code extensions have the same bug.
              But it is a bug.
            <p>
              The long version, now? That’s the rest of this talk.<br>
              Why is it necessary for extensions to do this?<br>
              Why don’t extensions do this?<br>
              How can we make it easier for extensions to do this?
          </aside>
        </section>
        <section>
          <h2>There is no easy fix for this bug</h2>
          <ul>
            <li>There’s no workaround possible for users of buggy extensions
            <li>Core CPython changes will help but cannot eliminate the bug
            <li>Many extensions will need to change
          </ul>
          <aside class="notes">
            Before we get into the meat of this talk, I want to say up
            front: There’s no easy fix, and no workaround available
            for people who are just using the buggy extensions.  There
            are potential changes to the core CPython interpreter that
            will help, but only a little; they can’t make the whole
            problem go away.  Ultimately, every compiled code
            extension that can run for a long time without returning
            to the main interpreter loop will need to be changed.
          </aside>
        </section>
        <section>
          <h2>This talk is about development <em>of</em> Python</h2>
          <p class="left">You’ll get increasingly more out of it if…</p>
          <ul>
            <li>you’ve written code in compiled languages
            <li>you’ve written compiled-code extensions for CPython
            <li>you’ve looked at or worked on the code of CPython itself
            <br>(or PyPy, Perl, Ruby, Lua, etc.)
            <li>you’ve written code that uses Unix signal handlers
          </ul>
          <aside class="notes">
            So, the rest of this talk is going to be about those
            changes that need to be made, and why—and this necessarily
            gets into details of the innards of the CPython interpreter,
            and what happens at a low level when you type control-C.
            <p>
              I’m going to do my best to introduce these things
              gently, but I only have half an hour, so I’ll need
              to assume a bunch of background.
            <p>
              You’ll get more out of this talk if you have written
              compiled code extensions for CPython—or just if you
              have written code in a compiled language at all.
              You’ll get more out of it if you know the essence of
              how a bytecode interpreter works.  And if you already
              understand the dangers of Unix signal handling,
              there’s a big chunk that won’t be news to you.
            <p>
              By the way, all the measurements I made, all the code
              I’m going to show you, it was all prepared using Python
              3.12.  I haven’t had a chance to try anything newer.
            <p>
              So if you’re excited about the free threading project,
              I’m excited about it too, but you’re gonna hear me say
              “global interpreter lock” a lot and, thing is, I have
              the impression free threading doesn’t actually change
              the rules much about when you can and can’t call C-API
              functions.  Please mentally substitute “attached thread
              state” each time I say it.  Come find me afterward if
              you have notes.
          </aside>
        </section>
        <section>
          <h2>Why does this bug exist?</h2>
          <ul>
            <li>Not a problem for shell scripts</li>
            <li class="fragment">… but shell scripts don’t have structured
              exceptions</li>
            <li class="fragment">… and they get more help from the kernel</li>
          </ul>
          <aside class="notes">
            Let’s start with the big obvious question: Why do
            extensions need to call PyErr_CheckSignals in the first
            place?  Some other programming languages don’t have this
            problem at all—take shell scripts for example:
            the <code>sort</code> utility doesn’t, as far as I know,
            do anything special with control-C, but if you control-C a
            shell pipeline with a big <code>sort</code> in there
            somewhere, you get the shell prompt back immediately!
            <p>
              One answer to that is, Python is trying to be fancier
              than shell.  Python lets you “unwind” part way out of
              what you were doing, catch KeyboardInterrupt, and keep
              going.  Shell scripts don’t have anything like that.
            <p>
              Another answer is, shell scripts get more help from the
              OS kernel in dealing with this, which I’ll come back to
              at the very end of this talk.
            <p>
          </aside>
        </section>
        <section>
          <h2>What <kbd>Control-C</kbd> Does<sup>1</sup></h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <ul>
                <li>Starts out like any keystroke</li>
                <li>Converted to a <i>signal</i>, <code>SIGINT</code></li>
                <li>
                  <code>SIGINT</code> <span class="fragment highlight-green" data-fragment-index="1">delivered</span>
                  to Python interpreter</li>
                <li>Python interpreter <span class=
                "fragment highlight-blue" data-fragment-index="1">reacts</span> by raising
                <code>KeyboardInterrupt</code></li>
              </ul>
            </div>
            <div class="sidebyside-2">
              <div class="fragment green-box" data-fragment-index="2">
                <ul>
                  <li>C signal handler only sets a flag</li>
                  <li>Nothing more happens until control returns to
                    the main interpreter loop</li>
                </ul>
              </div>
              <div class="fragment blue-box" data-fragment-index="3">
                <ul>
                  <li>Main loop checks the flag in some (not all!) bytecode ops</li>
                  <li>If the flag is set, raises <code>KeyboardInterrupt</code></li>
                </ul>
              </div>
            </div>
          </div>
          <p class="footnote">
            <sup>1</sup> Except on Windows</p>
          <aside class="notes">
            To understand why CPython <em>needs</em> compiled
            code extensions to call PyErr_CheckSignals in order
            to be responsive to control-C, we need to understand
            what control-C actually does.
            <p>
              Control-C isn’t something Python invented, it’s at least
              a decade older, and part of how it works is built into
              the Unix kernel.
            <p>
              Footnote, what I’m about to tell you is how this works
              on every OS we care about <em>except</em> Windows.
              I don’t know what Windows does instead, I just know
              it’s different.  But, it’s not different in a way that
              <em>helps</em> with the bug we’re talking about,
              so it’s moot.
            <p>
              Control-C is the same as any other keystroke to your
              keyboard and to a whole bunch of processing stages we’re
              going to skip over.  ssh for instance just passes it
              along.  But right before it gets to the CPython process,
              a chunk of code inside the kernel, called the “terminal
              line discipline,” intercepts it, takes it out of the
              input stream and turns it into a thing called a “SIGINT
              signal” and delivers <em>that</em> to the process.  And
              the interpreter reacts to the signal by
              raising <code>KeyboardInterrupt</code>.
            <p>
              These words here. The signal is “delivered” and the
              interpreter “reacts.”  The delay we saw earlier is in
              between these words, and here’s why.
            <p>
              I’ll go into more detail about what “delivered” means
              in a moment, but the gist is, at the moment of delivery,
              a special function inside CPython runs and … all it does
              is set a flag.  Nothing more happens until CPython gets
              back to its main interpreter loop.
            <p>
              The main loop checks that flag as part of some bytecode
              instructions—if you look at <code>bytecodes.c</code>,
              it’s the ones that include the “check_periodic” “op”—and
              if they detect the flag is set, then the reaction
              happens, raising KeyboardInterrupt.
            <p>
              And this is also what PyErr_CheckSignals does: it checks
              the flag and it carries out the reaction of raising
              KeyboardInterrupt.
          </aside>
        </section>

        <section>
          <h2>Signal Delivery</h2>
          <pre class="language-python-repl short-example"
><span class="fragment semi-fade-out" data-fragment-index="1"><span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword h-namespace">import</span> <span class="h-name h-namespace">numpy</span> <span class="h-keyword">as</span> <span class="h-name h-namespace">np</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-variable">rng</span> <span class="h-operator">=</span> <span class="h-name">np</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-operator">.</span><span class="h-name">default_rng</span><span class="h-delim">()</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword">def</span> <span class="h-defun">g</span><span class="h-delim">(</span><span class="h-variable">n</span><span class="h-operator">=</span><span class="h-number h-integer">1000000000</span><span class="h-delim">):</span>
<span class="h-prompt">... </span>    <span class="h-keyword">return</span> <span class="h-name">rng</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-delim">(</span><span class="h-name">n</span><span class="h-delim">)</span>
<span class="h-prompt">...</span>
<span class="h-prompt">&gt;&gt;&gt; </span></span><span class="fragment" data-fragment-index="1"><span class="fragment semi-fade-out" data-fragment-index="2"><span class="h-name">g</span><span class="h-delim">()</span>
<span class="h-output">^C
Program received signal SIGINT
random_standard_uniform_fill ()
    at 0x00007ffff00b23a7</span>
<span class="h-prompt">(gdb)</span></span></span><span class="fragment" data-fragment-index="2"> signal SIGINT
<span class="h-output">Continuing with signal SIGINT.
Breakpoint 2, signal_handler (sig_num=2)
    at ./Modules/signalmodule.c:347</span>
<span class="h-prompt">(gdb)</span></span>
</pre>
          <aside class="notes">
            So why can’t the special signal handler function just
            raise KeyboardInterrupt itself, at the moment of delivery?
            Let’s look at what actually happens when a signal is
            delivered.  Here’s that random number generation function
            again.  I’m going to run it and interrupt it again…
            <p>
              but this time, I’ve hooked up CPython to
              the <em>C-level</em> debugger, GDB.  It intercepts the
              actual signal, and it gives you a chance to do something
              about it before the program ever sees it.
            <p>
              GDB is a very <em>talkative</em> program.
              I’ve cut a lot of unimportant detail out of the
              transcript on these slides.  If you try this yourself,
              it’ll look differently.
            <p>
              Notice what GDB says is on top of the C call stack just
              now.  random_standard_uniform_fill, that sounds like
              part of NumPy’s code for filling arrays with random
              numbers, yeah?
            <p>
              Now let’s let the signal go through to Python.  In
              advance, I set a breakpoint on the special signal
              handler function, so we immediately get told that
              we’re about to execute that function.
              The signal has been delivered at this point.
          </aside>
        </section>
        <section>
          <h2>Signal Delivery</h2>
          <pre class="language-text short-example"
><span class="fragment semi-fade-out" data-fragment-index="1"><span class="h-output">Breakpoint 2, signal_handler (sig_num=2)</span>
<span class="h-output">    at ./Modules/signalmodule.c:347</span>
<span class="h-prompt">(gdb)</span></span><span class="fragment" data-fragment-index="1"><span class="fragment semi-fade-out" data-fragment-index="2"> backtrace</span>
<span class="h-output"><span class="h-furniture">#0</span>  signal_handler <span class="h-furniture">(sig_num=2)</span></span>
<span class="h-output"><span class="h-furniture">#1</span>  &lt;signal handler called&gt;</span>
<span class="h-output"><span class="h-furniture">#2</span>  random_standard_uniform_fill <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#3</span>  __pyx_f_5numpy_6random_7_common_f…</span>
<span class="fragment semi-fade-out" data-fragment-index="2"><span class="h-output"><span class="h-furniture">#4</span>  __pyx_pw_5numpy_6random_10_genera…</span>
<span class="h-output"><span class="h-furniture">#5</span>  method_vectorcall_FASTCALL_KEYWOR…</span>
<span class="h-output"><span class="h-furniture">#6</span>  _PyObject_VectorcallTstate <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#7</span>  PyObject_Vectorcall <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#8</span>  _PyEval_EvalFrameDefault <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#9</span>  PyEval_EvalCode <span class="h-furniture">(…)</span></span></span></span>
</pre>
          <aside class="notes">
            I can’t fit the whole debugger transcript on one slide,
            so let’s scroll away the first bit.  We’re still right
            where we were at the end of the previous slide, stopped
            at a breakpoint, about to execute CPython’s special signal
            handling function.  Now let’s ask GDB for the C-level traceback.
            <p>
              GDB prints tracebacks the other way around from
              Python—the innermost frame is on <em>top</em>.
            <p>
              There’s a lot in there, let’s focus on the top four
              stack frames.  The innermost is the special signal
              handler function.  The next level up doesn’t seem to be
              a function at all, it just says “signal handler called”,
              and above <em>that</em> is, huh,
              random_standard_uniform_fill, where we were just before
              the signal was delivered, and above that is more of
              NumPy’s random numbers module.
          </aside>
        </section>
        <section>
          <h2>Signal Delivery</h2>
          <ul>
            <li class="fragment semi-fade-out" data-fragment-index="1">Signal delivery <strong>interrupts</strong> normal code execution
              <ul>
                <li>Exact analogy to hardware interrupts</li>
                <li>Kernel “preempts” execution of CPython</li>
                <li>Creates fake stack frames, to make CPU return to preemption point later</li>
                <li>Resumes execution at beginning of <code>signal_handler</code></li>
              </ul>
            </li>
            <li class="fragment" data-fragment-index="1">Preempted code could have been doing anything</li>
            <li class="fragment" data-fragment-index="1">Therefore, unsafe to do much within a signal handler</li>
          </ul>
          <aside class="notes">
              Signal delivery was invented by operating system
              programmers from the 1970s.  They thought in assembly
              language.  They designed signals to be like hardware
              interrupts.
            <p>
              At a completely arbitrary point between two machine
              instructions—it happened to be in
              random_standard_uniform_fill, but it could have been
              anywhere—the OS kernel has “preempted” execution of
              CPython, messed with the saved register state,
              written <em>fake</em> frames to the hardware call stack,
              and then restarted execution at the beginning of the
              signal handler function.
            <p>
              When <code>signal_handler</code> is done, the fake stack
              frames will make the CPU run a little bit of private
              code from the C library to clean up the mess—that’s what
              that “signal handler called” stack frame is about—and
              then return to exactly where it was in
              random_standard_uniform_fill, which will go on with
              whatever it was doing when it was preempted.
            <p>
              This is why CPython <em>needs</em> to have
              signal_handler just set a flag, with all further
              reaction postponed till we get back to a safe point,
              like the main interpreter loop.  The code that was
              interrupted could have been doing anything at all,
              we don’t know what, it’s not <em>safe</em> to do
              anything else.
          </aside>
        </section>
        <section>
          <h2>What <kbd>Control-C</kbd> Does<sup>1</sup></h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <ul>
                <li>Starts out like any keystroke</li>
                <li>Converted to a <i>signal</i>, <code>SIGINT</code></li>
                <li>
                  <code>SIGINT</code> <span class="highlighted-green" data-fragment-index="1">delivered</span> to Python interpreter</li>
                <li>Python interpreter <span class="highlighted-blue" data-fragment-index="2">reacts</span> by
                raising <code>KeyboardInterrupt</code></li>
              </ul>
            </div>
            <div class="sidebyside-2">
              <div class="green-box" data-fragment-index="1">
                <ul>
                  <li>C signal handler only sets a flag</li>
                  <li>Nothing more happens until control returns to
                    the main interpreter loop</li>
                </ul>
              </div>
              <div class="blue-box" data-fragment-index="2">
                <ul>
                  <li>Main loop checks the flag in some (not all!) bytecode ops</li>
                  <li>If the flag is set, raises <code>KeyboardInterrupt</code></li>
                </ul>
              </div>
            </div>
          </div>
          <p class="footnote">
            <sup>1</sup> Except on Windows</p>
          <aside class="notes">
            So to reiterate, control-C causes a “signal” to be
            delivered to CPython.  At the time of delivery, the
            interpreter just sets a flag.  Then it waits to get back
            to a point where it’s actually safe to raise a
            Python-level exception and unwind the Python call stack.
            <p>
              Safe points are embedded in Python bytecode instructions
              that occur frequently, so if the interpreter is
              executing regular Python, it never takes very long to
              get to a safe point.  But if it calls into a compiled
              module, then safe points only happen when the code of
              the module explicitly asks for them, by calling
              PyErr_CheckSignals.
          </aside>
        </section>
        <section>
          <h2>Why don’t extensions check the flag?</h2>
          <ol>
            <li>Need to call <code>PyErr_CheckSignals</code> is poorly
              documented</li>
            <li class="semi-faded">Adding calls may require tricky refactoring
              <ul>
                <li>to make safe places to call it</li>
                <li>to propagate a &minus;1 return all the way up</li>
              </ul>
            </li>
            <li class="semi-faded">Calling it is expensive
              <ul>
                <li>especially if you released the global interpreter
                  lock</li>
              </ul>
            </li>
          </ol>
          <aside class="notes">
            Now we understand why compiled extensions need to call
            PyErr_CheckSignals periodically, so the next big question
            is, why don’t they?
            <p>
              I see three reasons, and I’d like to begin with the most
              basic one: People writing compiled extensions maybe
              don’t know they should be doing this.
          </aside>
        </section>
        <section>
          <blockquote class="long-quote">
            <h2><code class="language-c"><span class="h-type h-keyword">int</span> <span class="h-defun">PyErr_CheckSignals</span><span class="h-delim">()</span></code></h2>
            <p><em>Part of the Stable ABI.</em></p>
            <p>This function interacts with Python’s signal handling.</p>
            <p>If the function is called from the main thread and under the main Python interpreter, it checks whether a
              signal has been sent to the processes and if so, invokes the corresponding signal handler.
              <span class="fragment highlight-red" data-fragment-index="2">If the signal
              module is supported, this can invoke a signal handler written in Python.</p>
            <p>The function attempts to handle all pending signals, and then returns 0. However, if a Python signal
              handler raises an exception, the error indicator is set and the function returns −1 immediately (such
              that other pending signals may not have been handled yet: they will be on the next
              <code>PyErr_CheckSignals()</code> invocation).</p>
            <p>If the function is called from a non-main thread, or under a non-main Python interpreter, it does nothing
              and returns 0.</p>
            <p class="fragment highlight-green" data-fragment-index="1">
              This function can be called by long-running C code that wants to be interruptible by user requests (such
              as by pressing Ctrl-C).</p>
            <p>Note: The default Python signal handler for <code>SIGINT</code> raises the <code>KeyboardInterrupt</code>
              exception.</p>
          </blockquote>
          <aside class="notes">
              Here’s the documentation for PyErr_CheckSignals.
              It’s a big wall of text.  I’m gonna highlight the
              crucial sentence:
            <p>
              “This function can be called by long-running code that
              wants to be interruptible.”
              That doesn’t sound nearly as important as it is.
              I might have written something like “Long-running code
              <em>needs</em> to call this function periodically in order
              for the interpreter to be responsive to user
              interrupts.”
            <p>
              And I’d have made it the first sentence!
            <p>
              Not to mention, before you can read this wall of text
              and realize its implications, you need to <em>find</em>
              it.
            <p>
              It’s buried in the “signal handling” section of the
              exception-handling chapter of the
              C-API <em>reference</em> manual.  The “extending and
              embedding” guide doesn’t mention it at all.
            <p>
              There’s another sentence in here that’s very
              important and very easy to miss.  This one.
            <p>
              “If the signal module is supported, this can invoke a
              handler written in Python.”
            <p>
              PyErr_CheckSignals might run arbitrary Python code
              before returning to you.
          </aside>
        </section>
        <section>
          <h2>Why don’t extensions check the flag?</h2>
          <ol>
            <li class="semi-faded">Need to call <code>PyErr_CheckSignals</code> is poorly
              documented</li>
            <li>Adding calls may require tricky refactoring
              <ul>
                <li>to make safe places to call it</li>
                <li>to propagate a &minus;1 return all the way up</li>
              </ul>
            </li>
            <li class="semi-faded">Calling it is expensive
              <ul>
                <li>especially if you released the global interpreter
                  lock</li>
              </ul>
            </li>
          </ol>
          <aside class="notes">
            So now we know we need to do this, but <em>how</em> do we
            do this?  Keeping in mind everything we just fished out of
            the documentation?  It’s not necessarily an easy refactor.
          </aside>
        </section>
        <section>
          <h2>How to check: a simple example</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-c"
><span class="h-keyword h-type"><span class="fragment custom delete" data-fragment-index="1">void</span></span>
<span class="fragment semi-fade-out" data-fragment-index="1"><span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t *</span><span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">npy_intp</span> <span class="h-variable">cnt</span><span class="h-delim">,</span> <span class="h-keyword h-type">double</span> <span class="h-type">*</span><span class="h-variable">out</span>
<span class="h-delim">) {</span>


  <span class="h-type">npy_intp</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">cnt</span><span class="h-delim">;</span> <span class="h-name">i</span><span class="h-operator">++</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span>




  <span class="h-delim">}</span>

<span class="h-delim">}</span></span></pre>
            </div>
            <div class="sidebyside-2 fragment" data-fragment-index="1">
              <pre class="language-c"
><span class="h-keyword h-type"><ins>int</ins></span>
<span class="semi-faded"><span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t *</span><span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">npy_intp</span> <span class="h-variable">cnt</span><span class="h-delim">,</span> <span class="h-keyword h-type">double</span> <span class="h-type">*</span><span class="h-variable">out</span>
<span class="h-delim">) {</span>


  <span class="h-type">npy_intp</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">cnt</span><span class="h-delim">;</span> <span class="h-name">i</span><span class="h-operator">++</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span></span>
<ins>    <span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">PyErr_CheckSignals</span><span class="h-delim">())</span></ins>
<ins>      <span class="h-keyword">return</span> <span class="h-number h-integer">-1</span><span class="h-delim">;</span></ins>


  <span class="h-delim semi-faded">}</span>
<ins>  <span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span></ins>
<span class="h-delim semi-faded">}</span></pre>
            </div>
          </div>
          <aside class="notes">
            Here’s probably the simplest case: the source of the
            random_standard_uniform_fill function from NumPy.  This is
            what got interrupted to deliver the signal, earlier.
            If we want this to be interruptible at all, we have to
            put a call to PyErr_CheckSignals inside the loop…
            <p>
              like this, maybe.
            <p>
              Notice that I changed the return type from void to int.
              Just like any other C-API function that can fail, when
              it returns &minus;1, it’s telling you that the error
              indicator has been set—to KeyboardInterrupt—and you need
              to clean up and return immediately, and tell your caller
              to clean up and return immediately, and so on all the
              way up the call stack.  You might need to deallocate
              resources.  You might need to roll back transactions.
              The cascade of changes is probably not too bad for this
              function, though.
            <p>
              Also, by making this function interruptible we’ve
              introduced a new bug.
          </aside>
        </section>
        <section>
          <h2>How to check: a simple example</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-c"
><span class="h-keyword h-type"><ins>int</ins></span>
<span class="semi-faded"><span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t *</span><span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">npy_intp</span> <span class="h-variable">cnt</span><span class="h-delim">,</span> <span class="h-keyword h-type">double</span> <span class="h-type">*</span><span class="h-variable">out</span>
<span class="h-delim">) {</span>


  <span class="h-type">npy_intp</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">cnt</span><span class="h-delim">;</span> <span class="h-name">i</span><span class="h-operator">++</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span></span>
<ins class="fragment custom delete" data-fragment-index="1">    <span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">PyErr_CheckSignals</span><span class="h-delim">())</span></ins>
<ins class="fragment custom delete" data-fragment-index="1">      <span class="h-keyword">return</span> <span class="h-number h-integer">-1</span><span class="h-delim">;</span></ins>


  <span class="h-delim semi-faded">}</span>
<ins>  <span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span></ins>
<span class="h-delim semi-faded">}</span></pre>
            </div>
            <div class="sidebyside-2 fragment" data-fragment-index="1">
              <pre class="language-c"
><ins><span class="h-keyword h-type">int</span></ins>
<span class="semi-faded"><span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t *</span><span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">npy_intp</span> <span class="h-variable">cnt</span><span class="h-delim">,</span> <span class="h-keyword h-type">double</span> <span class="h-type">*</span><span class="h-variable">out</span>
<span class="h-delim">) {</span></span>
<ins>  <span class="h-type">PyGILState_STATE</span> <span class="h-variable">st</span><span class="h-delim">;</span></ins>
<ins>  <span class="h-keyword h-type">int</span> <span class="h-variable">err</span><span class="h-delim">;</span></ins>
<span class="semi-faded">  <span class="h-type">npy_intp</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">cnt</span><span class="h-delim">;</span> <span class="h-name">i</span><span class="h-operator">++</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span></span>
<ins>    <span class="h-name">st</span> <span class="h-operator">=</span> <span class="h-name">PyGILState_Ensure</span><span class="h-delim">();</span></ins>
<ins>    <span class="h-name">err</span> <span class="h-operator">=</span> <span class="h-name">PyErr_CheckSignals</span><span class="h-delim">();</span></ins>
<ins>    <span class="h-name">PyGILState_Release</span><span class="h-delim">(</span><span class="h-name">st</span><span class="h-delim">);</span></ins>
<ins>    <span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">err</span><span class="h-delim">)</span> <span class="h-keyword">return</span> <span class="h-name">err</span><span class="h-delim">;</span></ins>
  <span class="h-delim semi-faded">}</span>
<ins>  <span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span></ins>
<span class="h-delim semi-faded">}</span>
</pre>
            </div>
          </div>
          <aside class="notes">
            Remember PyErr_CheckSignals can run arbitrary Python code
            before coming back to you?  That means it needs the global
            interpreter lock, and this function was called with the
            global interpreter lock released. NumPy is diligent about
            releasing the lock when it’s running loops like this.
            <p>
              So we can’t just call PyErr_CheckSignals.  We need to
              use PyGILState_Ensure to <em>reclaim</em> the lock for
              just long enough to call PyErr_CheckSignals, and then
              release it again.
            <p>
              PyGILState_Ensure and _Release are buried pretty deep in
              the manual, too, and using them can be troublesome, see
              PEP 788 for gory details—but they’re the only functions
              I can find that do what we need in this case, namely
              reclaim the lock if it was released, but don’t deadlock
              if this thread already holds the lock, and don’t require
              a PyThreadState argument.  If you have a better idea,
              please come tell me about it afterward.
          </aside>
        </section>
        <section>
          <h2>Why don’t extensions check the flag?</h2>
          <ol>
            <li class="semi-faded">Need to call <code>PyErr_CheckSignals</code> is poorly
              documented</li>
            <li class="semi-faded">Adding calls may require tricky refactoring
              <ul>
                <li>to make safe places to call it</li>
                <li>to propagate a &minus;1 return all the way up</li>
              </ul>
            </li>
            <li>Calling it is expensive
              <ul>
                <li>especially if you released the global interpreter
                  lock</li>
              </ul>
            </li>
          </ol>
          <aside class="notes">
            And this brings us to my third reason why extensions tend
            to have this bug: the most straightforward fix involves
            adding an expensive function call to all the hottest
            loops.  Especially if you release the global interpreter
            lock around those loops, because then you have to retake
            and re-release it around each call.
            <p>
              But how expensive is it really?
            <p>
              I put on my lab coat and I measured it.
          </aside>
        </section>
        <section>
          <h2>A more complicated example</h2>
          <div class="r-stack">
            <!-- 1x1 transparent gif as the lowest layer -->
            <img class="figure" width="1147" height="860" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
            <object class="figure-nobg fragment" data="kfft-underlay-botloops.svg" type="image/svg+xml" data-fragment-index="3"></object>
            <object class="figure-nobg fragment" data="kfft-underlay-toploops.svg" type="image/svg+xml" data-fragment-index="2"></object>
            <object class="figure-nobg fragment" data="kfft-underlay-recurse.svg" type="image/svg+xml" data-fragment-index="1"></object>
            <object class="figure-nobg" data="kfft-example-1.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data="kfft-overlay-insertpoints.svg" type="image/svg+xml"></object>
          </div>
          <aside class="notes">
            I didn’t measure the changes to the NumPy “generate a
            zillion random numbers” loop that I’ve been showing you,
            though, I measured the changes to this.  It’s more
            complicated in terms of what needs to be done to it, but
            still simple enough to cram onto one slide.  It’s the core
            of the simplest fast Fourier transform implementation I
            could find.  Originally written by a fellow name of Mark
            Borgerding.  Are you in the audience today, Mark?
            <p>
              [if he is] Thank you for …<br>
              [if he isn’t] Well, I’d like to thank him for …<br>
              writing an FFT implementation I could easily make sense of.
            <p>
              What I want you to see is that this is a recursive
              function—the recursive call is inside this loop in the
              middle, highlighted in brown—the base case is up top,
              highlighted in green, and after either of those finishes
              it always does one of these calls down at the bottom,
              highlighted in purple.
            <p>
              Each of these blocks does a linear pass over the input
              array.
            <p>
              Now we know checking could be expensive, and if we
              studied the algorithm in detail we’d see that the
              compiler might be able to vectorize the innermost loops.
              That’s great for speed, we don’t want to lose that.
              Adding a function call to any loop pretty much kills its
              chances of getting vectorized.  And the innermost loops
              run fast enough that even at the biggest problem sizes,
              they complete in microseconds.  It’s fine to have a
              delay as much as a few tens of <em>milli</em>seconds
              when responding to control-C.
            <p>
              So I think a reasonable first cut at making this
              responsive to control-C without hurting performance
              much would be to add checks in these two places: right
              after each pass over the input.
          </aside>
        </section>
        <section>
          <h2>Cost of checking for signals</h2>
          <div class="r-stack">
            <object class="figure" data="cost-check-sp-1.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data="cost-check-sp-2.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data="cost-check-sp-3.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data="cost-check-sp-4.svg" type="image/svg+xml"></object>
          </div>
          <aside class="notes">
            I wrote a test module wrapping Mark Borgerding’s FFT that
            lets me benchmark it with or without signal checks, and
            with or without releasing the GIL around the whole
            computation.
            <p>
              All benchmarks were run single-threaded, meaning the GIL
              was never contended, so the numbers you’re going to see
              are the best possible case for GIL-related overhead.
            <p>
              Without any signal checks, and without releasing the
              GIL, I measured this nice linear relationship between
              FFT problem size and execution time.  Note both axes are
              on a log scale.
            <p>
              Releasing the GIL once at the beginning and reclaiming
              it once at the end doesn’t add any measurable overhead.
            <p>
              If we don’t release the GIL, enabling signal checks is
              pretty cheap.  No signals are actually sent in this
              test, we’re measuring how much it costs to have the
              checks even when they have nothing to do, like they
              would most of the time.
            <p>
              But if we do release the GIL, suddenly the signal checks
              are a lot more expensive.
          </aside>
        </section>
        <section>
          <div class="r-stack">
            <h2 class="fragment fade-out" data-fragment-index="1">Cost of checking for signals</h2>
            <h2 class="fragment fade-in-then-out" data-fragment-index="1">What if we didn’t check every time?</h2>
            <h2 class="fragment fade-in" data-fragment-index="2">Claw back more speed with coarse clock</h2>
          </div>
          <div class="r-stack">
            <object class="figure" data="cost-per-sample-1.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data-fragment-index="1" data="cost-per-sample-2.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data-fragment-index="2"
                    data="cost-per-sample-3.svg" type="image/svg+xml"></object>
          </div>
          <aside class="notes">
            It’s hard to compare the slopes of lines by eye, so this
            plot shows what we get if we divide out the problem size.
            The recursive structure of the FFT implementation means
            there’s still an <em>effect</em> of the problem size, but
            we can see the effect of turning on checks, more easily.
            Up top, here, the difference between the top two strips
            shows the overhead of signal checks with the GIL held.
            I’m still calling PyGILState_Ensure and _Release around
            each call to PyErr_CheckSignals, but they never have any
            real work to do.  The cost is small but it’s still there.
            <p>
              On the other hand, down below, this shows the overhead
              of signal checks with the GIL released, so we have to
              reclaim it for each call to PyErr_CheckSignals, and it’s
              a lot.  The FFT is something like three to four times
              slower in this mode.
            <p>
              The obvious thing to do about this is not check as
              often.  We already aren’t checking after every
              iteration; but what if we literally look at the clock?
              Ask the OS if at least a millisecond has gone by since
              the last time we called PyErr_CheckSignals; only reclaim
              the GIL and call it, if it has.  Human responsiveness
              will be plenty good enough.
            <p>
              The new third strip on each half of this plot shows what
              we get if we do that.  Looking at the clock slows us
              down a little more when we didn’t release the GIL, but
              speeds us up a whole lot when we did; the overhead with
              GIL released is now basically the same as the overhead
              with it held.  That’s great.
            <p>
              Most of the remaining overhead is the cost of looking at
              the clock all the time.  Some operating systems offer a
              “coarse” realtime clock that’s plenty good enough to
              tell us if a millisecond has gone by.  That version is
              efficient enough that the performance cost is barely
              measurable except for the biggest problem sizes.
          </aside>
        </section>
        <section>
          <h2>Longer intervals don’t help</h2>
          <div class="r-stack">
          <object class="figure" data="cost-by-interval-median.svg" type="image/svg+xml"></object>
          </div>
          <aside class="notes">
            You might be thinking, 1 millisecond is still awful short.
            But it’s long enough to the CPU that the lion’s share of
            the remaining overhead is <em>the overhead of looking at
            the clock</em>, and we can’t make that any smaller by
            increasing the interval between calls to
            PyErr_CheckSignals.
          </aside>
        </section>
        <section>
          <h2>Recap</h2>
          <ul>
            <li>CPython interpreter cannot raise
              <code>KeyboardInterrupt</code> directly from its
              C-level signal handler
              <ul>
                <li>Must return to main interpreter loop before raising exceptions</li>
                <li>Prompt return needs cooperation from compiled-code extensions</li>
              </ul>
            </li>
            <li>Many extensions do not cooperate
              <ul>
                <li>Need to do this has not been well advertised</li>
                <li>Retrofit requires finicky code changes</li>
                <li>Substantial runtime costs</li>
              </ul>
            </li>
          </ul>
          <aside class="notes">
            Recap: The CPython interpreter cannot raise
            KeyboardInterrupt directly from its C-level signal
            handler, it must return to its main loop first.  To do
            that promptly when the signal interrupted a compiled-code
            extension, requires cooperation from that extension.
            <p>
              Many extensions don’t cooperate, and we’ve just seen
              why: it’s not well advertised that you need to do this,
              it requires finicky code changes, and it has substantial
              runtime costs if you’re not careful about it.
          </aside>
        </section>
        <section>
          <h2>Short term: look at the clock</h2>
          <pre class="language-c"
><span class="h-keyword h-type">int</span> <span class="h-defun">CheckSignalsOftenEnough</span><span class="h-delim">(</span><span class="h-keyword h-type">void</span><span class="h-delim">)</span> <span class="h-delim">{</span>
  <span class="h-keyword">static</span> <span class="h-keyword h-type">struct</span> <span class="h-type">timespec</span> <span class="h-variable">last_check</span> <span class="h-operator">=</span> <span class="h-delim">{</span> <span class="h-number h-integer">0</span><span class="h-delim">,</span> <span class="h-number h-integer">0</span> <span class="h-delim">};</span>
  <span class="h-keyword h-type">struct</span> <span class="h-type">timespec</span> <span class="h-variable">now</span><span class="h-delim">;</span>
  <span class="h-name">clock_gettime</span><span class="h-delim">(</span><span class="h-name">CLOCK_MONOTONIC_COARSE</span><span class="h-delim">,</span> <span class="h-operator">&amp;</span><span class="h-name">now</span><span class="h-delim">);</span>

  <span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">timespec_difference_at_least</span><span class="h-delim">(</span><span class="h-operator">&amp;</span><span class="h-name">now</span><span class="h-delim">,</span> <span class="h-operator">&amp;</span><span class="h-name">last_check</span><span class="h-delim">,</span> <span class="h-name">ONE_MS_IN_NS</span><span class="h-delim">))</span> <span class="h-delim">{</span>
    <span class="h-name">last_check</span> <span class="h-operator">=</span> <span class="h-name">now</span><span class="h-delim">;</span>
    <span class="h-type">PyGILState_STATE</span> <span class="h-variable">st</span> <span class="h-operator">=</span> <span class="h-name">PyGILState_Ensure</span><span class="h-delim">();</span>
    <span class="h-keyword h-type">int</span> <span class="h-name">err</span> <span class="h-operator">=</span> <span class="h-name">PyErr_CheckSignals</span><span class="h-delim">();</span>
    <span class="h-name">PyGILState_Release</span><span class="h-delim">(</span><span class="h-name">st</span><span class="h-delim">);</span>
    <span class="h-keyword">return</span> <span class="h-name">err</span><span class="h-delim">;</span>
  <span class="h-delim">}</span>
  <span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span>
<span class="h-delim">}</span></pre>
          <p class="footnote">
            Full version:
            <a href="https://github.com/MillionConcepts/cpython-ext-ctrl-c/blob/main/CheckSignalsOftenEnough.c"
               ><code>https://github.com/MillionConcepts/cpython-ext-ctrl-c/blob/main/CheckSignalsOftenEnough.c</code></a>
          </p>
          <aside class="notes">
            Here’s my short-term performance fix.  Look at the clock,
            reclaim the GIL once a millisecond to check for signals.
            <p>
              You can grab the full code for this from the link at the
              bottom of this slide.  Copy and paste it into your
              extension.  Call <code>CheckSignalsOftenEnough</code> at
              appropriate moments.  You still have to figure out where
              to do that, and how to propagate the failure back out of
              your extension, but it takes care of looking at the
              clock and being GIL-safe for you.  It’s only been tested
              on Linux and NetBSD but I sincerely hope it doesn’t need
              any more portability gunk than what it has now.
            <p>
              3-clause BSD license.  If you want a different license
              contact my boss about it.
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul class="fragment" data-fragment-index="1"><li>Improve core documentation
              <ul>
                <li>Highlight need to call <code>PyErr_CheckSignals</code> regularly</li>
                <li>Explain how to do so safely</li>
                <li>Explain how to do so efficiently</li>
                <li><a href="https://github.com/python/cpython/issues/134075">gh-134075</a>
              </ul>
          </li></ul>
          <div class="zany-o-meter fragment" data-fragment-index="1">zaniness: 0</div>
          <aside class="notes">
            <p>
              So. This helps, but can we do better?
            <p>
              I have some ideas, which I will now tell you,
              in ascending order of zaniness.
            <p>
              First off, let’s improve the documentation so people know
              they need to do this and they know how to do it safely and
              efficiently.  I think it deserves its own section in the
              “extending and embedding” guide.
            <p>
              This is not a zany idea at all.  We should do this.
              I filed a docs improvement request already.
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Don’t require GIL to call <code>PyErr_CheckSignals</code>
              <ul>
                <li>Cost of frequent checks is mostly cost of locking</li>
                <li>Signal flag is an atomic variable! Don’t need GIL to test it</li>
                <li>Have <code>PyErr_CheckSignals</code> reclaim GIL
                     itself, before running Python signal handlers,
                  <em>only if flag is set</em></li>
                <li>(Still needs to be <em>safe</em> to take GIL at any callsite)</li>
                <li>Proposed for Python 3.14: <a href="https://github.com/python/cpython/issues/133465">gh-133465</a></li>
              </ul>
          </li></ul>
          <div class="zany-o-meter" data-fragment-index="1">zaniness: 0</div>
          <aside class="notes">
            Maybe we could push the PyGILState_Ensure calls down into
            PyErr_CheckSignals, making it safe to call with or without
            the GIL, as long as it’s safe to take the GIL at the
            callsite?  The signal flag itself is an atomic variable,
            so PyErr_CheckSignals could test the flag without taking
            the GIL, and only take the GIL if the flag is set.
            <p>
              This would eliminate any need to look at the clock and
              space out the calls.  CheckSignalsOftenEnough could just
              be PyErr_CheckSignals.  You’d still want to avoid
              calling it on every single iteration, though, if only
              because that would block the compiler from vectorizing
              your loops.
            <p>
              Also not a zany idea at all in my opinion, I have
              written a patch for Python 3.14 that does this.
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Make Cython, Numba, and similar tools insert checks for you</li></ul>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-cython"
><span class="h-keyword">cdef</span> <span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t</span> <span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">double</span> <span class="h-delim">[:]</span> <span class="h-variable">out</span><span class="h-delim">,</span>
<span class="h-delim">)</span> <span class="h-keyword">nogil</span><span class="h-delim">:</span>
    <span class="h-keyword">for</span> <span class="h-variable">i</span> <span class="h-operator-word">in</span> <span class="h-name h-builtin">range</span><span class="h-delim">(</span><span class="h-name h-builtin">len</span><span class="h-delim">(</span><span class="h-name">out</span><span class="h-delim">)):</span>
        <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">)</span></pre>
            </div>
            <div class="sidebyside-2">
              <pre class="language-c"
><span class="fragment semi-fade-out" data-fragment-index="2"><span class="h-keyword h-type">int</span> <span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t</span> <span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">__Pyx_memviewslice</span> <span class="h-variable">out</span>
<span class="h-delim">)</span> <span class="h-delim">{</span>
  <span class="h-type">Py_ssize_t</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-type">Py_ssize_t</span> <span class="h-variable">len</span><span class="h-delim">;</span>
  <span class="h-name">len</span> <span class="h-operator">=</span> <span class="h-name">__Pyx_MemoryView_Len</span><span class="h-delim">(</span><span class="h-name">out</span><span class="h-delim">);</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">len</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">+=</span> <span class="h-number h-integer">1</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-operator">*</span><span class="h-delim">((</span><span class="h-keyword h-type">double</span> <span class="h-operator">*</span><span class="h-delim">)</span>
      <span class="h-delim">((</span><span class="h-name">out</span><span class="h-delim">.</span><span class="h-name">data</span> <span class="h-operator">+</span>
        <span class="h-name">i</span> <span class="h-operator">*</span> <span class="h-name">out</span><span class="h-delim">.</span><span class="h-name">strides</span><span class="h-delim">[</span><span class="h-number h-integer">0</span><span class="h-delim">])))</span> <span class="h-operator">=</span>
      <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span></span>
<span class="fragment custom insert" data-fragment-index="2">    <span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">CheckSignalsOftenEnough</span><span class="h-delim">())</span></span>
<span class="fragment custom insert" data-fragment-index="2">      <span class="h-keyword">return</span> <span class="h-number h-integer">-1</span><span class="h-delim">;</span></span>
<span class="fragment semi-fade-out" data-fragment-index="2">  <span class="h-delim">}</span>
  <span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span>
<span class="h-delim">}</span></span>
</pre>
            </div>
          </div>
          <div class="zany-o-meter fragment" data-fragment-index="2">zaniness: 1</div>
          <aside class="notes">
            Lots of NumPy is written in Cython; here’s an approximate
            Cython version of random_standard_uniform_fill, and here’s
            the C code generated for it now.
            <p>
            Maybe the Cython compiler, and Numba, and so on, could
            insert the necessary calls for us?  Like this.  Or even
            better, make it happen only once every 16,384 iterations
            and avoid getting in the way of vectorization.
            <p>
            This one’s maybe a little bit zany.  I think it should be
            doable but I’ve never looked at the guts of Cython.
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>In tools like PyO3, model control-C as async cancellation</li></ul>
          <pre class="language-rust"
><span class="h-directive">#[pyfunction]</span>
<span class="h-keyword">async</span> <span class="h-keyword">fn</span> <span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-directive">#[pyo3(cancel_handle)]</span> <span class="h-keyword">mut</span> <span class="h-variable">cancel</span><span class="h-delim">:</span> <span class="h-type">CancelHandle</span><span class="h-delim">,</span>
    <span class="h-variable">rng</span><span class="h-delim">:</span> <span class="h-type">BitGen</span><span class="h-delim">,</span>
    <span class="h-variable">out</span><span class="h-delim">:</span> <span class="h-keyword h-type">&amp;mut</span> <span class="h-type">f64[]</span><span class="h-delim">,</span>
<span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">futures</span><span class="h-delim">::</span><span class="h-name">select</span><span class="h-operator">!</span> <span class="h-delim">{</span>
        <span class="h-name">cancel</span><span class="h-delim">.</span><span class="h-name">cancelled</span><span class="h-delim">.</span><span class="h-name">fuse</span><span class="h-delim">()</span> <span class="h-operator">=&gt;</span> <span class="h-delim">{},</span>
        <span class="h-name">_</span> <span class="h-operator">=&gt;</span> <span class="h-delim">{</span>
            <span class="h-keyword">for</span> <span class="h-variable">i</span> <span class="h-keyword">in</span> <span class="h-number h-integer">0</span><span class="h-operator">..</span><span class="h-name">out</span><span class="h-delim">.</span><span class="h-name">len</span><span class="h-delim">()</span> <span class="h-delim">{</span>
                <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">rng</span><span class="h-delim">.</span><span class="h-name">next_double</span><span class="h-delim">();</span>
            <span class="h-delim">}</span>
        <span class="h-delim">}</span>
    <span class="h-delim">}</span>
<span class="h-delim">}</span>
</pre>
          <div class="zany-o-meter">zaniness: 5</div>
          <aside class="notes">
            If you’re writing your compiled code by hand, a library
            can’t help you very much… or can it?  Rust has cancellable
            asynchronous functions.  Maybe PyO3 could map control-C
            onto asynchronous cancellation.  Here’s a completely
            hypothetical example of how this might look.
            <p>
              Getting somewhat zany here.  This <em>could</em> be
              totally straightforward, or it could turn into a bit of
              a research project, but I don’t think it’s impossible.
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <ul>
                <li>Turn Python into a shell-structured language</li>
                <li class="fragment fade-up" data-fragment-index="1">Evaluate each step in a <em>subprocess</em></li>
              </ul>
            </div>
            <div class="sidebyside-2">
              <pre class="language-python-repl"
><span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword h-namespace">import</span> <span class="h-name h-namespace">numpy</span> <span class="h-keyword">as</span> <span class="h-name h-namespace">np</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-variable">rng</span> <span class="h-operator">=</span> <span class="h-name">np</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-operator">.</span><span class="h-name">default_rng</span><span class="h-delim">()</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword">def</span> <span class="h-defun">g</span><span class="h-delim">(</span><span class="h-variable">n</span><span class="h-operator">=</span><span class="h-number h-integer">1000000000</span><span class="h-delim">):</span>
<span class="h-prompt">... </span>    <span class="h-keyword">return</span> <span class="h-name">rng</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-delim">(</span><span class="h-name">n</span><span class="h-delim">)</span>
<span class="h-prompt">...</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-name">g</span><span class="h-delim">()</span></pre>
            </div>
          </div>
          <ul class="fragment fade-up" data-fragment-index="1">
            <li>Pass results back via pipes or shared memory or something</li>
            <li>Let the subprocess die on SIGINT</li>
            <li>This is why the Unix shell doesn’t have the same problem</li>
          </ul>
          <div class="zany-o-meter fragment fade-up" data-fragment-index="1"
               >zaniness: <img src="z/dragon-head.svg" height="80"></div>
          <aside class="notes">
            Remember I said shell scripts get more help from the
            kernel?  Remember I said the <code>sort</code> utility
            probably doesn’t have any special handling for control-C,
            and yet, when you control-C a pipeline with sort in it, it
            stops immediately?  How does that work, anyway?
            <p>
              The answer is, subprocesses.
            <p>
              Because (we presume) the sort process <em>doesn’t</em>
              have a handler for SIGINT, instead of “delivering” the
              signal the kernel just kills off the process, along with
              the rest of the pipeline, and the shell gets control
              back immediately.  We could, in theory, restructure the
              CPython virtual machine to work the same way.
            <p>
              Here be dragons, right?  This would be a huge project.
              There’s implications for language semantics.  There’s
              probably at least two “how do we even do this” research
              studies in there somewhere.  But: it’s the only idea
              I’ve got that would let us <em>not</em> have to add
              PyErr_CheckSignals calls to every compiled code
              extension on PyPI!
            <p>
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Brainstorming time!
              <ul>
                <li>Call out your ideas</li>
                <li>Or ask a question</li>
                <li>One sentence per person</li>
              </ul>
          </li></ul>
          <aside class="notes">
            That was the zaniest of my ideas.  Now I’d like to hear yours.
            Call ’em out.  One sentence per person.  Or ask a question.
          </aside>
        </section>
        <section>
          <h2>Acknowledgments</h2>
          <ul class="long-list">
            <li><p>Slides, code samples, raw data,
              and analysis scripts may be found<br>
              at <a href="https://github.com/MillionConcepts/cpython-ext-ctrl-c"><code>https://github.com/MillionConcepts/cpython-ext-ctrl-c</code></a><br>
              or <a href="https://git.sr.ht/~zackw/cpython-ext-ctrl-c"><code>https://git.sr.ht/~zackw/cpython-ext-ctrl-c</code></a><br>
              and may be reused under Million Concepts’ usual 3-clause BSD license</p></li>
            <li><a href="https://github.com/mborgerding/kissfft">KISS FFT</a> originally written by Mark Borgerding</li>
            <li>Data visualization thanks to <a href="https://ggplot2.tidyverse.org/">ggplot2</a> and <a href="https://wilkelab.org/cowplot/">cowplot</a></li>
            <li>Graphics postprocessed to various degrees in <a href="https://inkscape.org/">Inkscape</a></li>
            <li>Slide deck rendered with <a href="https://revealjs.com/">reveal.js</a></li>
            <li>Fonts are <a href="https://github.com/polarsys/b612"><code>B612 Mono</code></a>, <a href="https://github.com/alerque/libertinus">Libertinus Sans</a>, and <a href="https://www.1001freefonts.com/quando.font"><span class="use-heading-font">Quando</span></a></li>
            <li><a href="https://openclipart.org/detail/217264/dragon-sketch">Dragon head</a> by <a href="https://openclipart.org/artist/Lazur">Lazur</a> from openclipart.org</li>
            <li>Financial support from <a href="https://science.nasa.gov/astrophysics/programs/research-programs/">NASA ADAP</a> grant 80NSSC21K1421</li>
          </ul>
        </section>
      </div>
    </div>
    <script src="rjs/reveal.js"></script>
    <script src="rjs/plugin-notes.js"></script>
    <script src="rjs/init.js"></script>
  </body>
</html>
<!--
  -- Local Variables:
  -- sgml-basic-offset: 2;
  -- End:
  -->
