<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no">
    <title>Writing Extension Modules to be Interruptible</title>
    <link rel="stylesheet" href="rjs/theme-mc-sol-dark.css">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <div class="l-title-card">
            <h1>Writing Extension Modules<br>to be Interruptible</h1>
            <div class="author-card">
              <img src="picassohead-me.svg" width="240" height="240">
              <div class="author-handles">
                <p><strong>Zack Weinberg</strong></p>
                <p>〈<code class="email">zack@millionconcepts.com</code>〉</p>
                <p>〈<code class="email">zack@owlfolio.org</code>〉</p>
                <p><a href="https://www.owlfolio.org"><code>https://www.owlfolio.org/</code></a></p>
              </div>
            </div>
            <a class="venue" href="https://us.pycon.org/2025/"><img src="pycon-2025-us-logo.svg" alt="PyCon US 2025" height="70" width="218"></a>
          </div>
        </section>
        <section>
          <h2>A Common Bug</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <div class="r-stack">
                <pre class="language-python-repl"
>&gt;&gt;&gt; import random
&gt;&gt;&gt; def f(n=100000000):
...     return [random.random()
...         for _ in range(n)]
...
&gt;&gt;&gt; f()
</pre>
                <pre class="fragment language-python-repl" data-fragment-index="1"
>&gt;&gt;&gt; import random
&gt;&gt;&gt; def f(n=100000000):
...     return [random.random()
...         for _ in range(n)]
...
&gt;&gt;&gt; f()
^C
</pre>
                <pre class="fragment language-python-repl" data-fragment-index="2"
>&gt;&gt;&gt; import random
&gt;&gt;&gt; def f(n=100000000):
...     return [random.random()
...         for _ in range(n)]
...
&gt;&gt;&gt; f()
^CTraceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in f
KeyboardInterrupt
&gt;&gt;&gt;
</pre>
              </div>
              <p class="fragment" data-fragment-index="4"><span class="r-frame">&nbsp;&lt; 0.1 s&nbsp;</span></p>
            </div>
            <div class="sidebyside-2">
              <div class="r-stack">
                <pre class="language-python-repl"
>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; def g(n=1000000000):
...     return rng.random(n)
...
&gt;&gt;&gt; g()
</pre>
                <pre class="fragment language-python-repl" data-fragment-index="1"
>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; def g(n=1000000000):
...     return rng.random(n)
...
&gt;&gt;&gt; g()
^C
</pre>
                <pre class="fragment language-python-repl" data-fragment-index="3"
>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; def g(n=1000000000):
...     return rng.random(n)
...
&gt;&gt;&gt; g()
^CTraceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in g
KeyboardInterrupt
&gt;&gt;&gt;
</pre>
              </div>
              <p class="fragment" data-fragment-index="4"><span class="r-frame">&nbsp;3.5 s&nbsp;</span></p>
            </div>
          </div>
        </section>
        <section>
          <h2>What went wrong</h2>
          <ul>
            <li>NumPy didn’t call <code>PyErr_CheckSignals</code></li>
            <li>Common bug in compiled-code extensions</li>
            <li class="fragment fade-up">This talk is about:
              <ol>
                <li>Why extensions need to do that</li>
                <li>Why, today, many extensions <i>don’t</i> do that</li>
                <li>How we can make it easier to do that</li>
              </ol></li>
          </ul>
        </section>
        <section>
          <h2>Audience background check</h2>
          <p>Raise your hand if…</p>
          <ul>
            <li class="fragment">you’ve written code in a compiled language
              <ul>
                <li class="fragment">C or assembly, specifically</li>
              </ul></li>
            <li class="fragment">you’ve written a compiled-code extension for CPython
              <ul>
                <li class="fragment">using the C-API directly, no helper libraries</li>
              </ul></li>
            <li class="fragment">you’ve written a multithreaded program</li>
            <li class="fragment">you’ve written a signal handler</li>
            <li class="fragment">you know the difference between thread-safe and async-signal-safe</li>
          </ul>
        </section>
        <section>
          <h2>What <kbd>Control-C</kbd> Does<sup>1</sup></h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <ul>
                <li>Starts out like any keystroke</li>
                <li>Converted to a <i>signal</i>, <code>SIGINT</code></li>
                <li class="fragment fade-up" data-fragment-index="1">
                  <code>SIGINT</code> <span class="fragment highlight-green" data-fragment-index="2">delivered</span>
                  to Python interpreter</li>
                <li class="fragment fade-up" data-fragment-index="1">Python interpreter <span class=
                "fragment highlight-blue" data-fragment-index="2">reacts</span> by raising
                <code>KeyboardInterrupt</code></li>
              </ul>
            </div>
            <div class="sidebyside-2"></div>
          </div>
          <p class="footnote">
            <sup>1</sup> Except on Windows</p>
        </section>
        <section>
          <h2>Signal Delivery</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <div class="r-stack">
                <pre class="language-python-repl"
>&gt;&gt;&gt; import random
&gt;&gt;&gt; def f(n=100000000):
...     return [random.random()
...         for _ in range(n)]
...
&gt;&gt;&gt; f()
</pre>
                <pre class="fragment language-python-repl" data-fragment-index="1"
>&gt;&gt;&gt; import random
&gt;&gt;&gt; def f(n=100000000):
...     return [random.random()
...         for _ in range(n)]
...
&gt;&gt;&gt; f()
^C
Program received signal SIGINT
pymalloc_pool_extend ()
    at Objects/obmalloc.c:1361
(gdb)
</pre>
                <pre class="fragment language-python-repl" data-fragment-index="2"
>&gt;&gt;&gt; import random
&gt;&gt;&gt; def f(n=100000000):
...     return [random.random()
...         for _ in range(n)]
...
&gt;&gt;&gt; f()
^C
Program received signal SIGINT
pymalloc_pool_extend ()
    at Objects/obmalloc.c:1361
(gdb) signal SIGINT
Continuing with signal SIGINT.
Breakpoint 2, signal_handler (sig_num=2)
    at ./Modules/signalmodule.c:347
(gdb)
</pre>
              </div>
            </div>
            <div class="sidebyside-2">
              <div class="r-stack">
                <pre class="language-python-repl"
>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; def g(n=1000000000):
...     return rng.random(n)
...
&gt;&gt;&gt; f()
</pre>
                <pre class="fragment language-python-repl" data-fragment-index="1"
>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; def g(n=1000000000):
...     return rng.random(n)
...
&gt;&gt;&gt; f()
^C
Program received signal SIGINT
random_standard_uniform_fill ()
    at 0x00007ffff00b23a7
(gdb)
</pre>
                <pre class="fragment language-python-repl" data-fragment-index="2"
>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; def g(n=1000000000):
...     return rng.random(n)
...
&gt;&gt;&gt; f()
^C
Program received signal SIGINT
random_standard_uniform_fill ()
    at 0x00007ffff00b23a7
(gdb) signal SIGINT
Continuing with signal SIGINT.
Breakpoint 2, signal_handler (sig_num=2)
    at ./Modules/signalmodule.c:347
(gdb)
</pre>
              </div>
            </div>
          </div>
        </section>
        <section>
          <h2>Signal Delivery</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-text" data-line-numbers="|4,5,6" data-fragment-index="1"
>Breakpoint 2, signal_handler (sig_num=2)
    at ./Modules/signalmodule.c:347
(gdb) backtrace
#0  signal_handler (sig_num=2)
#1  &lt;signal handler called&gt;
#2  pymalloc_pool_extend (…)
#3  pymalloc_alloc (…)
#4  _PyObject_Malloc (…)
#5  _PyLong_FromMedium (…)
#6  PyLong_FromLong (…)
#7  _PyEval_EvalFrameDefault (…)
#8  PyEval_EvalCode (…)

(etc. etc.)
</pre>
            </div>
            <div class="sidebyside-2">
              <pre class="language-text" data-line-numbers="|4,5,6" data-fragment-index="1"
>Breakpoint 2, signal_handler (sig_num=2)
    at ./Modules/signalmodule.c:347
(gdb) backtrace
#0  signal_handler (sig_num=2)
#1  &lt;signal handler called&gt;
#2  random_standard_uniform_fill (…)
#3  __pyx_f_5numpy_6random_7_common_f… (…)
#4  __pyx_pw_5numpy_6random_10_genera… (…)
#5  method_vectorcall_FASTCALL_KEYWORDS (…)
#6  _PyObject_VectorcallTstate (…)
#7  PyObject_Vectorcall (…)
#8  _PyEval_EvalFrameDefault (…)
#9  PyEval_EvalCode (…)
</pre>
            </div>
          </div>
        </section>
        <section>
          <h2>How did we get here???</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <div class="r-stack">
                <pre class="language-text" data-line-numbers="|3|3|4" data-fragment-index="1"
>(gdb) backtrace
#0  signal_handler (sig_num=2)
#1  &lt;signal handler called&gt;
#2  pymalloc_pool_extend (…)
…
</pre>
              </div>
            </div>
            <div class="sidebyside-2">
              <div class="r-stack">
                <pre class="language-text">(gdb)
</pre>
                <pre class="fragment language-text" data-fragment-index="1"
>(gdb) up
#1 &lt;signal handler called&gt;
(gdb)
</pre>
                <pre class="fragment language-text" data-fragment-index="2"
>(gdb) up
#1 &lt;signal handler called&gt;
(gdb) disassemble
Assembly dump of __restore_rt:
=&gt; &lt;+0&gt;:    mov $SYS_rt_sigreturn,%rax
   &lt;+7&gt;:    syscall
(gdb)
</pre>
                <pre class="fragment language-text" data-fragment-index="3"
>(gdb) up
#1 &lt;signal handler called&gt;
(gdb) disassemble
Assembly dump of __restore_rt:
=&gt; &lt;+0&gt;:    mov $SYS_rt_sigreturn,%rax
   &lt;+7&gt;:    syscall
(gdb) up
#2 pymalloc_pool_extend (…)
(gdb) disassemble
Assembly dump of pymalloc_pool_extend:
...
   &lt;+473&gt;:  mov    %ecx,0x28(%rdx)
=&gt; &lt;+476&gt;:  movq   $0x0,(%rdi)
...
</pre>
              </div>
            </div>
          </div>
        </section>
        <section>
          <h2>The black magic of signal delivery</h2>
          <div class="sidebyside">
            <div class="sidebyside-1 r-stack">
              <ul>
                <li>Kernel “preempted” execution of <code>pymalloc_pool_extend</code></li>
                <li>
                  <em>Forged</em> stack frames to make CPU <em>behave as if</em> <code>pymalloc_pool_extend</code>
                  called <code>__restore_rt</code> which called <code>signal_handler</code></li>
                <li>Resumed execution at beginning of <code>signal_handler</code></li>
              </ul>
            </div>
            <div class="sidebyside-2 r-stack">
              <pre class="language-text"
>(gdb) up
#1 &lt;signal handler called&gt;
(gdb) disassemble
Assembly dump of __restore_rt:
=&gt; &lt;+0&gt;:    mov $SYS_rt_sigreturn,%rax
   &lt;+7&gt;:    syscall
(gdb) up
#2 pymalloc_pool_extend (…)
(gdb) disassemble
Assembly dump of pymalloc_pool_extend:
...
   &lt;+473&gt;:  mov    %ecx,0x28(%rdx)
=&gt; &lt;+476&gt;:  movq   $0x0,(%rdi)
...
</pre>
            </div>
          </div>
        </section>
        <section>
          <h2>What <kbd>Control-C</kbd> Does<sup>1</sup></h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <ul>
                <li>Starts out like any keystroke</li>
                <li>Converted to a <i>signal</i>, <code>SIGINT</code></li>
                <li>
                  <code>SIGINT</code> delivered to Python interpreter</li>
                <li>Python interpreter <span class="fragment highlight-blue" data-fragment-index="1">reacts</span> by
                raising <code>KeyboardInterrupt</code></li>
              </ul>
            </div>
            <div class="sidebyside-2">
              <div class="fragment pale-blue-box" data-fragment-index="1">
                <ul>
                  <li>C signal handler only sets a flag</li>
                  <li>Nothing more happens until control returns to the main interpreter loop</li>
                  <li>Main loop checks the flag in some (not all!) bytecode ops</li>
                  <li>If the flag is set, raises <code>KeyboardInterrupt</code></li>
                </ul>
              </div>
            </div>
          </div>
          <p class="footnote">
            <sup>1</sup> Except on Windows</p>
        </section>
        <section>
          <h2>What NumPy isn’t doing</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-python"
>def f(out, rng):
    for i in range(len(out)):
        out[i] = rng.random()
</pre>
              <pre class="fragment fade-up language-pybytecode" data-fragment-index="1"
> [42] FOR_ITER         to [96]
       STORE_FAST       1 (i)
       LOAD_FAST        2 (rng)
       LOAD_ATTR        5 (NULL|self + random)
       CALL             0
       LOAD_FAST        0 (out)
       LOAD_FAST        1 (i)
       STORE_SUBSCR
       JUMP_BACKWARD   to [42]
  [96] END_FOR
</pre>
            </div>
            <div class="sidebyside-2">
              <div class="r-stack">
                <pre class="language-c"
>void random_standard_uniform_fill(
    bitgen_t *bitgen,
    npy_intp cnt, double *out)
{
  npy_intp i;
  for (i = 0; i &lt; cnt; i++) {
    out[i] = next_double(bitgen);
  }
}
</pre>
                <pre class="fragment language-c" data-fragment-index="3" data-line-numbers="7,8,10"
>int random_standard_uniform_fill(
    bitgen_t *bitgen,
    npy_intp cnt, double *out)
{
  npy_intp i;
  for (i = 0; i &lt; cnt; i++) {
    out[i] = next_double(bitgen);
    if (PyErr_CheckSignals())
      return -1;
  }
  return 0;
}
</pre>
              </div>
              <pre class="fragment fade-up language-asm" data-fragment-index="2"
>.L3:
    mov     rdi, r12
    call    next_double
    movsd   qword ptr [r13 + rbx*8], xmm0
    add     rbx, 1
    cmp     rbp, rbx
    jne     .L3
</pre>
            </div>
          </div>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <ul>
            <li>Abstractly simple
              <ul>
                <li>Call <code>PyErr_CheckSignals</code> periodically</li>
                <li>If it returns −1, treat as failure; abandon work, return</li>
              </ul></li>
          </ul>
        </section>
        <section>
          <blockquote class="long-quote">
            <h2><code class="language-c"><span class="h-type h-keyword">int</span> <span class="h-defun">PyErr_CheckSignals</span><span class="h-delim">()</span></code></h2>
            <p><em>Part of the Stable ABI.</em></p>
            <p>This function interacts with Python’s signal handling.</p>
            <p>If the function is called from the main thread and under the main Python interpreter, it checks whether a
              signal has been sent to the processes and if so, invokes the corresponding signal handler. If the signal
              module is supported, this can invoke a signal handler written in Python.</p>
            <p>The function attempts to handle all pending signals, and then returns 0. However, if a Python signal
              handler raises an exception, the error indicator is set and the function returns −1 immediately (such
              that other pending signals may not have been handled yet: they will be on the next
              <code>PyErr_CheckSignals()</code> invocation).</p>
            <p>If the function is called from a non-main thread, or under a non-main Python interpreter, it does nothing
              and returns 0.</p>
            <p class="fragment highlight-green">
              This function can be called by long-running C code that wants to be interruptible by user requests (such
              as by pressing Ctrl-C).</p>
            <p>Note: The default Python signal handler for <code>SIGINT</code> raises the <code>KeyboardInterrupt</code>
              exception.</p>
          </blockquote>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <ul>
            <li class="pastbullet">Abstractly simple
              <ul>
                <li>Call <code>PyErr_CheckSignals</code> periodically</li>
                <li>If it returns −1, treat as failure; abandon work, return</li>
              </ul></li>
            <li>Not obvious from docs that you <em>need</em> to do that</li>
          </ul>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre data-line-numbers="1,7,8,10" class="language-c"
>void random_standard_uniform_fill(
    bitgen_t *bitgen,
    npy_intp cnt, double *out)
{
  npy_intp i;
  for (i = 0; i &lt; cnt; i++) {
    out[i] = next_double(bitgen);


  }

}
</pre>
            </div>
            <div class="sidebyside-2">
              <pre data-line-numbers="1,7,8,10" class="language-c"
>int random_standard_uniform_fill(
    bitgen_t *bitgen,
    npy_intp cnt, double *out)
{
  npy_intp i;
  for (i = 0; i &lt; cnt; i++) {
    out[i] = next_double(bitgen);
      if (PyErr_CheckSignals())
        return -1;
  }
  return 0;
}
</pre>
            </div>
          </div>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <ul>
            <li class="pastbullet">Abstractly simple
              <ul>
                <li>Call <code>PyErr_CheckSignals</code> periodically</li>
                <li>If it returns −1, treat as failure; abandon work, return</li>
              </ul></li>
            <li class="pastbullet">Not obvious from docs that you <em>need</em> to do that</li>
            <li>Have to decide <em>where</em> and <em>how often</em> to do that</li>
            <li>Must propagate the −1 return all the way up your call chain</li>
          </ul>
        </section>
        <section>
          <blockquote class="long-quote">
            <h2><code class="language-c"><span class="h-type h-keyword">int</span> <span class="h-defun">PyErr_CheckSignals</span><span class="h-delim">()</span></code></h2>
            <p><em>Part of the Stable ABI.</em></p>
            <p>This function interacts with Python’s signal handling.</p>
            <p>If the function is called from the main thread and under the main Python interpreter, it checks whether a
              signal has been sent to the processes and if so, invokes the corresponding signal handler. <span class=
              "fragment highlight-red">If the signal module is supported, this can invoke a signal handler written in
              Python.</span></p>
            <p>The function attempts to handle all pending signals, and then returns 0. However, if a Python signal
              handler raises an exception, the error indicator is set and the function returns −1 immediately (such
              that other pending signals may not have been handled yet: they will be on the next
              <code>PyErr_CheckSignals()</code> invocation).</p>
            <p>If the function is called from a non-main thread, or under a non-main Python interpreter, it does nothing
              and returns 0.</p>
            <p style="color:#17ff2e">
              This function can be called by long-running C code that wants to be interruptible by user requests (such
              as by pressing Ctrl-C).</p>
            <p>Note: The default Python signal handler for <code>SIGINT</code> raises the <code>KeyboardInterrupt</code>
              exception.</p>
          </blockquote>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <ul>
            <li class="pastbullet">Abstractly simple
              <ul>
                <li>Call <code>PyErr_CheckSignals</code> periodically</li>
                <li>If it returns −1, treat as failure; abandon work, return</li>
              </ul></li>
            <li class="pastbullet">Not obvious from docs that you <em>need</em> to do that</li>
            <li class="pastbullet">Have to decide <em>where</em> and <em>how often</em> to do that</li>
            <li class="pastbullet">Must propagate the −1 return all the way up your call chain</li>
            <li>
              <code>PyErr_CheckSignals</code> can run arbitrary Python code
              <ul>
                <li>Needs to be <em>safe</em> to run arbitrary Python</li>
                <li>May need to reclaim the GIL (expensive)</li>
              </ul></li>
          </ul>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre data-line-numbers="1,5,6,9-12,14" class="language-c"
>void random_standard_uniform_fill(
    bitgen_t *bitgen,
    npy_intp cnt, double *out)
{


  npy_intp i;
  for (i = 0; i &lt; cnt; i++) {
    out[i] = next_double(bitgen);




  }

}
</pre>
            </div>
            <div class="sidebyside-2">
              <pre data-line-numbers="1,5,6,9-12,14" class="language-c"
>int random_standard_uniform_fill(
    bitgen_t *bitgen,
    npy_intp cnt, double *out)
{
  PyGILState_STATE st;
  int err;
  npy_intp i;
  for (i = 0; i &lt; cnt; i++) {
    out[i] = next_double(bitgen);
    st = PyGILState_Ensure();
    err = PyErr_CheckSignals();
    PyGILState_Release();
    if (err) return err;
  }
  return 0;
}
</pre>
            </div>
          </div>
        </section>
        <section>
          <h2>A more complicated example</h2>
          <div class="r-stack">
            <img class="figure" src="kfft-example-1.svg">
            <img class="figure-nobg fragment" src="kfft-example-2.svg">
          </div>
        </section>
        <section>
          <h2>Cost of checking for signals</h2>
          <div class="r-stack">
            <img class="figure" src="cost-check-sp-1.svg">
            <img class="figure-nobg fragment" src="cost-check-sp-2.svg">
            <img class="figure-nobg fragment" src="cost-check-sp-3.svg">
            <img class="figure-nobg fragment" src="cost-check-sp-4.svg">
          </div>
        </section>
        <section>
          <div class="r-stack">
            <h2>Cost of checking for signals</h2>
          </div>
          <div class="r-stack">
            <img class="figure" src="cost-per-sample-1.svg">
          </div>
        </section>
        <section>
          <h2>What if we didn’t check every time?</h2>
          <div class="r-stack">
            <img class="figure" src="kfft-example-1.svg">
            <img class="figure-nobg fragment fade-out" data-fragment-index="1" src="kfft-example-2.svg">
            <img class="figure-nobg fragment fade-in" data-fragment-index="1" src="kfft-example-3.svg">
          </div>
        </section>
        <section>
          <div class="r-stack">
            <h2 class="fragment fade-out" data-fragment-index="1">What if we didn’t check every time?</h2>
            <h2 class="fragment fade-in" data-fragment-index="1">Claw back more speed with coarse clock</h2>
          </div>
          <div class="r-stack">
            <img class="figure" src="cost-per-sample-1.svg">
            <img class="figure-nobg" src="cost-per-sample-2.svg">
            <img class="figure-nobg fragment" data-fragment-index="1" src="cost-per-sample-3.svg">
          </div>
        </section>
        <section>
          <h2>Longer intervals don’t help</h2>
          <div class="r-stack">
          <img class="figure" src="cost-by-interval-median.svg">
          </div>
        </section>
        <section>
          <h2>Recap</h2>
          <ul>
            <li>CPython interpreter cannot raise
              <code>KeyboardInterrupt</code> directly from its
              C-level signal handler
              <ul>
                <li>Must return to main interpreter loop before raising exceptions</li>
                <li>Prompt return needs cooperation from compiled-code extensions</li>
              </ul>
            </li>
            <li>Many extensions do not cooperate
              <ul>
                <li>Need to do this has not been well advertised</li>
                <li>Retrofit requires finicky code changes</li>
                <li>Substantial runtime costs</li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h2>Short term recommendation</h2>
          <pre class="language-c long-example"
>#ifndef CLOCK_MONOTONIC_COARSE
#define CLOCK_MONOTONIC_COARSE  CLOCK_MONOTONIC
#endif
#define ONE_MS_IN_NS 1000000
#define ONE_S_IN_NS  1000000000

int CheckSignalsOftenEnough()
{
  static struct timespec last_check = { 0, 0 };
  struct timespec now;
  clock_gettime(CLOCK_MONOTONIC_COARSE, &amp;now);

  if (   now.tv_sec < last_check.tv_sec        // monotonic clock went backward?!
      || now.tv_sec > last_check.tv_sec + 1    // more than 1s since last check
      || (now.tv_sec == last_check.tv_sec      // same second, more than 1ms
          && now.tv_nsec > last_check.tv_nsec + ONE_MS_IN_NS)
      || now.tv_nsec + ONE_S_IN_NS             // different second, ditto
         > last_check.tv_nsec + ONE_MS_IN_NS
  ) {
    last_check = now;
    PyGILState_STATE s = PyGilState_Ensure();
    int err = PyErr_CheckSignals();
    PyGILState_Release(s);
    return err;
  }
  return 0;
}
</pre>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Improve core documentation
              <ul>
                <li>Highlight need to call <code>PyErr_CheckSignals</code> regularly</li>
                <li>Explain how to do so safely</li>
                <li>Explain how to do so efficiently</li>
              </ul>
          </li></ul>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Don’t require GIL to call <code>PyErr_CheckSignals</code>
              <ul>
                <li>Cost of frequent checks is mostly cost of locking</li>
                <li>Signal flag is already an atomic variable! Don’t need GIL to test it</li>
                <li>Have <code>PyErr_CheckSignals</code> claim GIL itself, <em>only if flag is set</em></li>
                <li>(Still needs to be <em>safe</em> to take GIL at any callsite)</li>
                <li>Proposed for Python 3.14: [TODO: pull request URL]</li>
              </ul>
          </li></ul>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Make Cython, Numba, and similar tools insert checks for you</li></ul>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-cython"
>cdef random_standard_uniform_fill(
    bitgen gen,
    double [:] out,
) nogil:
    for i in range(len(out)):
        out[i] = next_double(gen)
</pre>
            </div>
            <div class="sidebyside-2">
              <pre class="language-c"
>int random_standard_uniform_fill(
    bitgen gen,
    __Pyx_memviewslice out
) {
  Py_ssize_t i;
  Py_ssize_t len;

  len = __Pyx_MemoryView_Len(out);
  for (i = 0; i &lt; len; i += 1) {
    *((double *)
      ((out.data +
        i * out.strides[0]))) =
      next_double(gen);
    <span class="fragment">if (CheckSignalsOftenEnough())
      return -1;</span>
  }

  return 0;
}
</pre>
            </div>
          </div>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>In tools like PyO3, model control-C as async cancellation</li></ul>
          <pre class="language-rust"
>#[pyfunction]
async fn random_standard_uniform_fill(
    #[pyo3(cancel_handle)] mut cancel: CancelHandle,
    gen: BitGen,
    out: &amp;mut f64[],
) {
    futures::select! {
        cancel.cancelled.fuse() =&gt; {},
        _ =&gt; {
            for i in 0..out.len() {
                out[i] = gen.next_double();
            }
        }
    }
}
</pre>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Turn Python into a shell-structured language</li></ul>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="fragment language-python-repl" data-fragment-index="1"
>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; def g(n=1000000000):
...     return rng.random(n)
...
&gt;&gt;&gt; g()
</pre>
            </div>
            <div class="sidebyside-2">
              <ul>
                <li class="fragment" data-fragment-index="1">Evaluate <code>g()</code> in a <em>subprocess</em></li>
                <li class="fragment">(This is why the Unix shell doesn’t have the same problem)</li>
                <li class="fragment">Pass the result back via shared memory or something</li>
              </ul>
            </div>
          </div>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Brainstorming time!
              <ul>
                <li>Call out your ideas</li>
                <li>Or ask a question</li>
                <li>One sentence per person</li>
              </ul>
          </li></ul>
        </section>
        <section>
          <h2>Colophon</h2>
          <ul>
            <li><p>All the code shown in this presentation, the raw data,
              and the analysis scripts may be found<br>
              at <a href="https://github.com/MillionConcepts/cpython-ext-ctrl-c"><code>https://github.com/MillionConcepts/cpython-ext-ctrl-c</code></a><br>
              or <a href="https://git.sr.ht/~zackw/cpython-ext-ctrl-c"><code>https://git.sr.ht/~zackw/cpython-ext-ctrl-c</code></a><br>
              and may be reused under Million Concepts’ usual 3-clause BSD license</p></li>
            <li>Fonts used in this presentation: <a href="https://github.com/alerque/libertinus">Libertinus Sans</a> and <a href="https://github.com/polarsys/b612">B612 Mono</a></li>
            <li>Data visualization thanks to <a href="https://ggplot2.tidyverse.org/">ggplot2</a> and <a href="https://wilkelab.org/cowplot/">cowplot</a></li>
            <li>Graphics postprocessed to various degrees in <a href="https://inkscape.org/">Inkscape</a></li>
            <li>Slide deck rendered with <a href="https://revealjs.com/">reveal.js</a>
          </ul>
        </section>
      </div>
      <script src="rjs/reveal.js"></script>
      <script src="rjs/plugin-notes.js"></script>
      <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
          hash: true,
          // Learn about plugins: https://revealjs.com/plugins/
          plugins: [ /*RevealMarkdown, RevealHighlight,*/ RevealNotes ],
          transition: "fade",
          center: false,
          width: 1920,
          height: 1080,
        });
      </script>
    </div>
  </body>
</html>
<!--
  -- Local Variables:
  -- sgml-basic-offset: 2;
  -- End:
  -->
