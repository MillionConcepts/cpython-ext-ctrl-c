<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no">
    <title>Writing Extension Modules to be Interruptible</title>
    <link rel="stylesheet" href="rjs/theme-mc-sol-dark.css">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <div class="l-title-card">
            <h1>Writing Extension Modules<br>to be Interruptible</h1>
            <div class="author-card">
              <img src="picassohead-me.svg" width="240" height="240"
                   alt="An abstract representation of my head, in profile">
              <div class="author-handles">
                <p><strong>Zack Weinberg</strong></p>
                <p>〈<code class="email">zack@millionconcepts.com</code>〉</p>
                <p>〈<code class="email">zack@owlfolio.org</code>〉</p>
                <p><a href="https://www.owlfolio.org"><code>https://www.owlfolio.org/</code></a></p>
              </div>
            </div>
            <div class="logos">
              <a class="employer" href="https://millionconcepts.com/"><img src="MC-logo.svg" alt="Million Concepts LLC" height="70"></a>
              <a class="venue" href="https://us.pycon.org/2025/"><img src="pycon-2025-us-logo.svg" alt="PyCon US 2025" height="100"></a>
            </div>
            <p class="footnote">If you’re reading this slide deck on
            the web, press S to bring up my notes.</p>
          </div>
          <aside class="notes">
            Hi, I’m Zack Weinberg and I’m here to talk about making
            extension modules interruptible—why that’s a thing you
            have to do by hand, and how to do it, and how to do
            it <em>efficiently</em>, and finally how we might change
            some things to make it easier.
          </aside>
        </section>
        <section>
          <h2>A Common Bug</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-python-repl"
><span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword h-namespace">import</span> <span class="h-name h-namespace">random</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword">def</span> <span class="h-defun">f</span><span class="h-delim">(</span><span class="h-variable">n</span><span class="h-operator">=</span><span class="h-number h-integer">100000000</span><span class="h-delim">):</span>
<span class="h-prompt">... </span>    <span class="h-keyword">return</span> <span class="h-delim">[</span><span class="h-name">random</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-delim">()</span>
<span class="h-prompt">... </span>        <span class="h-keyword">for</span> <span class="h-name">_</span> <span class="h-operator-word">in</span> <span class="h-name h-builtin">range</span><span class="h-delim">(</span><span class="h-name">n</span><span class="h-delim">)]</span>
<span class="h-prompt">...</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-name">f</span><span class="h-delim">()</span>
<span class="h-output fragment" data-fragment-index="1">^C</span
><span class="fragment" data-fragment-index="2"><span class="h-traceback">Traceback (most recent call last):
  File <span class="h-name h-builtin">&quot;&lt;stdin&gt;&quot;</span>, line <span class="h-number">1</span>, in <span class="h-name">&lt;module&gt;</span>
  File <span class="h-name h-builtin">&quot;&lt;stdin&gt;&quot;</span>, line <span class="h-number">2</span>, in <span class="h-name">f</span>
<span class="h-name h-class">KeyboardInterrupt</span></span>
<span class="h-prompt">&gt;&gt;&gt;</span></span></pre>
              <p class="fragment" data-fragment-index="4"><span class="r-frame">&nbsp;&lt; 0.1 s&nbsp;</span></p>
            </div>
            <div class="sidebyside-2">
              <pre class="language-python-repl"
><span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword h-namespace">import</span> <span class="h-name h-namespace">numpy</span> <span class="h-keyword">as</span> <span class="h-name h-namespace">np</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-variable">rng</span> <span class="h-operator">=</span> <span class="h-name">np</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-operator">.</span><span class="h-name">default_rng</span><span class="h-delim">()</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword">def</span> <span class="h-defun">g</span><span class="h-delim">(</span><span class="h-variable">n</span><span class="h-operator">=</span><span class="h-number h-integer">1000000000</span><span class="h-delim">):</span>
<span class="h-prompt">... </span>    <span class="h-keyword">return</span> <span class="h-name">rng</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-delim">(</span><span class="h-name">n</span><span class="h-delim">)</span>
<span class="h-prompt">...</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-name">g</span><span class="h-delim">()</span>
<span class="h-output fragment" data-fragment-index="1">^C</span
><span class="fragment" data-fragment-index="3"><span class="h-traceback">Traceback (most recent call last):
  File <span class="h-name h-builtin">&quot;&lt;stdin&gt;&quot;</span>, line <span class="h-number">1</span>, in <span class="h-name">&lt;module&gt;</span>
  File <span class="h-name h-builtin">&quot;&lt;stdin&gt;&quot;</span>, line <span class="h-number">2</span>, in <span class="h-name">g</span>
<span class="h-name h-class">KeyboardInterrupt</span></span>
<span class="h-prompt">&gt;&gt;&gt;</span></span></pre>
              <p class="fragment" data-fragment-index="4"><span class="r-frame">&nbsp;3.5 s&nbsp;</span></p>
            </div>
          </div>
          <aside class="notes">
            There’s an annoying bug, which probably everyone in this
            room has encountered, especially if you do a lot of
            interactive number crunching.
            <p>
              You set up a long calculation.  To demonstrate, I’m just
              gonna generate a whole lot of random numbers.  The
              function on the left uses the Python stdlib to generate
              them one at a time.  On the right, instead, we generate
              them all at once with NumPy.
            <p>
              We run them both at the same time…
            <p>
              … and immediately realize that we forgot to store the
              result in a variable, so we hit control-C …
            <p>
              … we get the prompt back immediately for the pure Python
              version, but we have to wait a bit for the NumPy
              version.
            <p>
              On my computer, it’s a few tenths of a second versus
              three and a half full seconds for this example.
            <p>
              It can be <em>minutes</em> if your calculation is big
              enough.  And all that CPU time is just <em>wasted</em>.
          </aside>
        </section>
        <section>
          <h2>What went wrong</h2>
          <ul>
            <li>NumPy didn’t call <code>PyErr_CheckSignals</code></li>
            <li>Common bug in compiled-code extensions</li>
            <li class="fragment fade-up">This talk is about:
              <ol>
                <li>Why extensions need to do that</li>
                <li>Why, today, many extensions <i>don’t</i> do that</li>
                <li>How we can make it easier to do that</li>
              </ol></li>
          </ul>
          <aside class="notes">
            Very short version of what went wrong:
            NumPy’s “fill array with random numbers” loop never
            called <code>PyErr_CheckSignals</code>.
            <p>
              I’m not here to pick on NumPy specifically.
              Lots of compiled code extensions have the same bug.
              But it is a bug.
            <p>
              The long version, now? That’s the rest of this talk.<br>
              Why is this something that you have to do?<br>
              Why don’t extensions do it already?<br>
              How can we make it easier for extensions to do the right
              thing here?
          </aside>
        </section>
        <section>
          <h2>Audience background check</h2>
          <p>Raise your hand if…</p>
          <ul>
            <li class="fragment">you’ve written code in a compiled language
              <ul>
                <li class="fragment">C or assembly, specifically</li>
              </ul></li>
            <li class="fragment">you’ve written a compiled-code extension for CPython
              <ul>
                <li class="fragment">using the C-API directly, no helper libraries</li>
              </ul></li>
            <li class="fragment">you’ve written a multithreaded program</li>
            <li class="fragment">you’ve written a signal handler</li>
            <li class="fragment">you know the difference between thread-safe and async-signal-safe</li>
          </ul>
          <aside class="notes">
            To understand why this is an issue in the first place, we
            have to go several layers below Python source code.  Almost
            all the way down to the bare metal, in fact.  So before I
            go on, I need to get a sense of how many of you have been
            down in those gears before.  [walk through poll on slide]
          </aside>
        </section>
        <section>
          <h2>What <kbd>Control-C</kbd> Does<sup>1</sup></h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <ul>
                <li>Starts out like any keystroke</li>
                <li>Converted to a <i>signal</i>, <code>SIGINT</code></li>
                <li class="fragment fade-up" data-fragment-index="1">
                  <code>SIGINT</code> <span class="fragment highlight-green" data-fragment-index="2">delivered</span>
                  to Python interpreter</li>
                <li class="fragment fade-up" data-fragment-index="1">Python interpreter <span class=
                "fragment highlight-blue" data-fragment-index="2">reacts</span> by raising
                <code>KeyboardInterrupt</code></li>
              </ul>
            </div>
            <div class="sidebyside-2"></div>
          </div>
          <p class="footnote">
            <sup>1</sup> Except on Windows</p>
          <aside class="notes">
            Control-C is the keystroke that tells the Python
            interpreter—and lots of other programs—that they should
            stop doing what they’re doing and give control back to an
            interactive command loop.  It’s at least a decade older
            than Python, and part of how it works is built into the
            Unix kernel.
            <p>
              Footnote, what I’m going to show in the next several
              slides is how this works on every OS we care about
              <em>except</em> Windows.  I don’t know what Windows
              does instead, I just know it’s different.  But, it’s
              not different in a way that <em>helps</em> with the
              bug I started with, so it’s moot.
            <p>
              Control-C starts out like any other keystroke, and it
              stays that way until just before it gets to the CPython
              process.  The “terminal line disciple,” the last stage
              of input processing before CPython, sees the control-C
              and, instead of passing it along to the Python process
              like regular input, it converts it to a thing called
              a <em>signal</em> and delivers <em>that</em> to the
              process.  And the interpreter reacts to that signal by
              raising <code>KeyboardInterrupt</code>.
            <p>
              These words here. The signal is “delivered” and the
              interpreter “reacts.”  The delay we saw earlier is in
              between these words.  To understand why compiled-code
              extensions get in the way of the interpreter reacting
              <em>immediately</em>, we need to understand exactly what
              these words mean.
          </aside>
        </section>
        <section>
          <h2>Signal Delivery</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-python-repl"
><span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword h-namespace">import</span> <span class="h-name h-namespace">random</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword">def</span> <span class="h-defun">f</span><span class="h-delim">(</span><span class="h-variable">n</span><span class="h-operator">=</span><span class="h-number h-integer">100000000</span><span class="h-delim">):</span>
<span class="h-prompt">... </span>    <span class="h-keyword">return</span> <span class="h-delim">[</span><span class="h-name">random</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-delim">()</span>
<span class="h-prompt">... </span>        <span class="h-keyword">for</span> <span class="h-name">_</span> <span class="h-operator-word">in</span> <span class="h-name h-builtin">range</span><span class="h-delim">(</span><span class="h-name">n</span><span class="h-delim">)]</span>
<span class="h-prompt">...</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-name">f</span><span class="h-delim">()</span>
<span class="fragment" data-fragment-index="1"><span class="h-output">^C
Program received signal SIGINT
pymalloc_pool_extend ()
    at Objects/obmalloc.c:1361</span>
<span class="h-prompt">(gdb)</span></span><span class="fragment" data-fragment-index="2"> signal SIGINT
<span class="h-output">Continuing with signal SIGINT.
Breakpoint 2, signal_handler (sig_num=2)
    at ./Modules/signalmodule.c:347</span>
<span class="h-prompt">(gdb)</span></span></pre>
            </div>
            <div class="sidebyside-2">
              <pre class="language-python-repl"
><span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword h-namespace">import</span> <span class="h-name h-namespace">numpy</span> <span class="h-keyword">as</span> <span class="h-name h-namespace">np</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-variable">rng</span> <span class="h-operator">=</span> <span class="h-name">np</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-operator">.</span><span class="h-name">default_rng</span><span class="h-delim">()</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword">def</span> <span class="h-defun">g</span><span class="h-delim">(</span><span class="h-variable">n</span><span class="h-operator">=</span><span class="h-number h-integer">1000000000</span><span class="h-delim">):</span>
<span class="h-prompt">... </span>    <span class="h-keyword">return</span> <span class="h-name">rng</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-delim">(</span><span class="h-name">n</span><span class="h-delim">)</span>
<span class="h-prompt">...</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-name">g</span><span class="h-delim">()</span>
<span class="fragment" data-fragment-index="1"><span class="h-output">^C
Program received signal SIGINT
random_standard_uniform_fill ()
    at 0x00007ffff00b23a7</span>
<span class="h-prompt">(gdb)</span></span><span class="fragment" data-fragment-index="2"> signal SIGINT
<span class="h-output">Continuing with signal SIGINT.
Breakpoint 2, signal_handler (sig_num=2)
    at ./Modules/signalmodule.c:347</span>
<span class="h-prompt">(gdb)</span></span>
</pre>
            </div>
          </div>
          <aside class="notes">
            Here’s those two versions of the random number generation
            function again.  We’re gonna run them again, and we’re
            gonna interrupt them again…
            <p>
              but this time, I’ve hooked up CPython to
              the <em>C-level</em> debugger, GDB.  It intercepts the
              actual signal, and it gives you a chance to do something
              about it before the program ever sees it.
            <p>
              Side note, GDB is a very <em>talkative</em> program.
              I’ve cut a lot of unimportant detail out of the
              transcript on these slides.  If you try this yourself,
              it’ll look differently.  Also I set some breakpoints in
              advance, which we’ll see in effect…
            <p>
              when we tell GDB to let the signal go through to Python,
              and we immediately get told that we’re now about to
              execute Python’s signal handler.
            <p>
              The signal has been delivered at this point, and the
              interpreter could, in principle react right now… but
              it’s not going to.  The <code>signal_handler</code>
              function is just going to set a flag, and the actual
              reaction—raising <code>KeyboardInterrupt</code>—won’t
              happen until we get back to the main interpreter loop.
            <p>
              That might seem like an unnecessary indirection,
              and it <em>is</em> the design-level cause of the
              delay due to NumPy in the code on the right,
              but there’s a good reason for it.
          </aside>
        </section>
        <section>
          <h2>Signal Delivery</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-text"
><span class="fragment semi-fade-out" data-fragment-index="1"><span class="h-output">Breakpoint 2, signal_handler (sig_num=2)</span>
<span class="h-output">    at ./Modules/signalmodule.c:347</span>
<span class="h-prompt">(gdb)</span> backtrace</span>
<span class="h-output"><span class="h-furniture">#0</span>  signal_handler <span class="h-furniture">(sig_num=2)</span></span>
<span class="h-output"><span class="h-furniture">#1</span>  &lt;signal handler called&gt;</span>
<span class="h-output"><span class="h-furniture">#2</span>  pymalloc_pool_extend <span class="h-furniture">(…)</span></span>
<span class="fragment semi-fade-out" data-fragment-index="1"><span class="h-output"><span class="h-furniture">#3</span>  pymalloc_alloc <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#4</span>  _PyObject_Malloc <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#5</span>  _PyLong_FromMedium <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#6</span>  PyLong_FromLong <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#7</span>  _PyEval_EvalFrameDefault <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#8</span>  PyEval_EvalCode <span class="h-furniture">(…)</span></span>

<span class="h-output">(etc. etc.)</span></span>
</pre>
            </div>
            <div class="sidebyside-2">
              <pre class="language-text"
><span class="fragment semi-fade-out" data-fragment-index="1"><span class="h-output">Breakpoint 2, signal_handler (sig_num=2)</span>
<span class="h-output">    at ./Modules/signalmodule.c:347</span>
<span class="h-prompt">(gdb)</span> backtrace</span>
<span class="h-output"><span class="h-furniture">#0</span>  signal_handler <span class="h-furniture">(sig_num=2)</span></span>
<span class="h-output"><span class="h-furniture">#1</span>  &lt;signal handler called&gt;</span>
<span class="h-output"><span class="h-furniture">#2</span>  random_standard_uniform_fill <span class="h-furniture">(…)</span></span>
<span class="fragment semi-fade-out" data-fragment-index="1"><span class="h-output"><span class="h-furniture">#3</span>  __pyx_f_5numpy_6random_7_common_f… <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#4</span>  __pyx_pw_5numpy_6random_10_genera… <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#5</span>  method_vectorcall_FASTCALL_KEYWORDS <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#6</span>  _PyObject_VectorcallTstate <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#7</span>  PyObject_Vectorcall <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#8</span>  _PyEval_EvalFrameDefault <span class="h-furniture">(…)</span></span>
<span class="h-output"><span class="h-furniture">#9</span>  PyEval_EvalCode <span class="h-furniture">(…)</span></span></span>
</pre>
            </div>
          </div>
          <aside class="notes">
            To understand why there’s this indirection, let’s look at
            the C-level traceback for both versions of the code, while
            we’re stopped at this breakpoint.  GDB prints tracebacks
            the other way around from Python—the innermost frame is
            on <em>top</em>.
            <p>
              There’s a lot in there, let’s focus on the innermost
              three stack frames.  Innermost is
              CPython’s <code>signal_handler</code> function, of
              course, but right above that we have this special
              “signal handler called” frame, and … huh.  Frame two
              is the code we were executing when the signal arrived.
              On the right we have NumPy’s “fill vector with random
              numbers” code, and on the left, that looks like we’re
              allocating memory.
          </aside>
        </section>
        <section>
          <h2>How did we get here???</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-text"
><span class="h-prompt">(gdb)</span> backtrace
<span class="fragment semi-fade-out h-output" data-fragment-index="1"><span class="h-furniture">#0</span>  signal_handler <span class="h-furniture">(sig_num=2)</span></span>
<span class="fragment custom semi-fade-in" data-fragment-index="1"><span class="fragment semi-fade-out h-output" data-fragment-index="3"><span class="h-furniture">#1</span>  &lt;signal handler called&gt;</span></span>
<span class="fragment custom semi-fade-in h-output" data-fragment-index="3"><span class="h-furniture">#2</span>  pymalloc_pool_extend <span class="h-furniture">(…)</span></span>
<span class="h-output semi-faded">...</span>
</pre>
            </div>
            <div class="sidebyside-2">
              <pre class="language-text"
><span class="h-prompt">(gdb)</span><span class="fragment" data-fragment-index="1"> up
<span class="h-output"><span class="h-furniture">#1</span>  &lt;signal handler called&gt;</span>
<span class="h-prompt">(gdb)</span></span><span class="fragment" data-fragment-index="2"> disassemble
<span class="h-output">Assembly dump of __restore_rt:</span>
<span class="h-output"><span class="h-furniture">=&gt; &lt;+0&gt;:</span>    <span class="h-opcode">mov</span>  <span class="h-variable">rax</span><span class="h-delim">,</span> <span class="h-constant">SYS_rt_sigreturn</span></span>
<span class="h-output"><span class="h-furniture">   &lt;+7&gt;:</span>    <span class="h-opcode">syscall</span></span>
<span class="h-prompt">(gdb)</span></span><span class="fragment" data-fragment-index="3"> up
<span class="h-output"><span class="h-furniture">#2</span>  pymalloc_pool_extend <span class="h-furniture">(…)</span></span>
<span class="h-prompt">(gdb)</span></span><span class="fragment" data-fragment-index="4"> disassemble
<span class="h-output">Assembly dump of pymalloc_pool_extend:</span>
<span class="h-output h-furniture">...</span>
<span class="h-output"><span class="h-furniture">   &lt;+473&gt;:</span>  <span class="h-opcode">mov</span>  dword <span class="h-delim">[</span><span class="h-name h-variable">rdx</span>+<span class="h-number h-integer">40</span><span class="h-delim">]</span><span class="h-delim">,</span> <span class="h-name h-variable">ecx</span></span>
<span class="h-output"><span class="h-furniture">=&gt; &lt;+476&gt;:</span>  <span class="h-opcode">mov</span>  qword <span class="h-delim">[</span><span class="h-name h-variable">rdi</span><span class="h-delim">]</span><span class="h-delim">,</span> <span class="h-number h-integer">0</span></span>
<span class="h-output h-furniture">...</span></span>
</pre>
            </div>
          </div>
          <aside class="notes">
            I need to make you <em>feel</em> this so I’m going to show
            you the assembly language involved.  Just for the
            pure-Python version, it’s the same principles for the
            other one.  <code>signal_handler</code> is just a regular
            C function, but if we go up a frame…
            <p>
              …and then ask for disassembly…
            <p>
              …huh, that’s a system call stub, and a strange one:
              there’s no more code after the <code>syscall</code>
              instruction.  Normally there should at least be a return
              instruction after the syscall.  And if you grep the
              entire CPython source code for dunder restore_rt, you
              won’t find it at all.
            <p>
              And it gets weirder if we go up another level.  This isn’t
              a function call sequence!  GDB thinks that at this level
              we’re gonna execute the instruction marked with the fat
              arrow next, but the instruction before that isn’t a call
              instruction.
          </aside>
        </section>
        <section>
          <h2>The black magic of signal delivery</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <ul>
                <li>Kernel “preempted” execution of <code>pymalloc_pool_extend</code></li>
                <li>
                  <em>Faked</em> two stack frames to make CPU <em>behave as if</em> <code>pymalloc_pool_extend</code>
                  called <code>__restore_rt</code> which called <code>signal_handler</code></li>
                <li>Resumed execution at beginning of <code>signal_handler</code></li>
              </ul>
            </div>
            <div class="sidebyside-2">
              <pre class="language-text"
><span class="h-prompt">(gdb)</span> up
<span class="h-output"><span class="h-furniture">#1</span>  &lt;signal handler called&gt;</span>
<span class="h-prompt">(gdb)</span> disassemble
<span class="h-output">Assembly dump of __restore_rt:</span>
<span class="h-output"><span class="h-furniture">=&gt; &lt;+0&gt;:</span>    <span class="h-opcode">mov</span>  <span class="h-variable">rax</span><span class="h-delim">,</span> <span class="h-constant">SYS_rt_sigreturn</span></span>
<span class="h-output"><span class="h-furniture">   &lt;+7&gt;:</span>    <span class="h-opcode">syscall</span></span>
<span class="h-prompt">(gdb)</span> up
<span class="h-output"><span class="h-furniture">#2</span>  pymalloc_pool_extend <span class="h-furniture">(…)</span></span>
<span class="h-prompt">(gdb)</span> disassemble
<span class="h-output">Assembly dump of pymalloc_pool_extend:</span>
<span class="h-output h-furniture">...</span>
<span class="h-output"><span class="h-furniture">   &lt;+473&gt;:</span>  <span class="h-opcode">mov</span>  dword <span class="h-delim">[</span><span class="h-name h-variable">rdx</span>+<span class="h-number h-integer">40</span><span class="h-delim">]</span><span class="h-delim">,</span> <span class="h-name h-variable">ecx</span></span>
<span class="h-output"><span class="h-furniture">=&gt; &lt;+476&gt;:</span>  <span class="h-opcode">mov</span>  qword <span class="h-delim">[</span><span class="h-name h-variable">rdi</span><span class="h-delim">]</span><span class="h-delim">,</span> <span class="h-number h-integer">0</span></span>
<span class="h-output h-furniture">...</span>
</pre>
            </div>
          </div>
          <aside class="notes">
            This is the black magic of signal delivery.
            <p>
              Signals don’t cancel execution of whatever they were
              doing when they arrive; they <em>interrupt</em> it.  At
              some completely arbitrary point—it happened to be in
              pymalloc_pool_extend, but it could have been anywhere—
              <em>between</em> two machine instructions, the OS has
              “preempted” execution of CPython, messed with the saved
              register state, and written
              <em>fake</em> stack frames to CPython’s machine stack,
              to make the CPU behave as if this arbitrary point in
              pymalloc_pool_extend had called dunder restore_rt, which
              in turn called signal_handler.
            <p>
              When <code>signal_handler</code> is done, the
              interpreter is going to go back to whatever it was doing
              when it was interrupted.
            <p>
              Raise your hand if you think it sounds safe for CPython
              to start the process of raising KeyboardInterrupt from
              some arbitrary point in the guts of the memory allocator.
            <p>
              It is CPython’s very own bespoke memory allocator, so
              maybe we <em>could</em> do that, but… could we do that
              from an arbitrary point somewhere inside some extension
              module?
            <p>
              Not without a whole lot of deliberate cooperation from
              that extension module, right?
            <p>
              This is why CPython needs to have that indirection,
              where signal_handler just sets a flag, and all further
              processing is postponed till we get back to the main
              interpreter loop.
          </aside>
        </section>
        <section>
          <h2>What <kbd>Control-C</kbd> Does<sup>1</sup></h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <ul>
                <li>Starts out like any keystroke</li>
                <li>Converted to a <i>signal</i>, <code>SIGINT</code></li>
                <li>
                  <code>SIGINT</code> <span class="fragment highlight-green" data-fragment-index="1">delivered</span> to Python interpreter</li>
                <li>Python interpreter <span class="fragment highlight-blue" data-fragment-index="2">reacts</span> by
                raising <code>KeyboardInterrupt</code></li>
              </ul>
            </div>
            <div class="sidebyside-2">
              <div class="fragment green-box" data-fragment-index="1">
                <ul>
                  <li>C signal handler only sets a flag</li>
                  <li>Nothing more happens until control returns to
                    the main interpreter loop</li>
                </ul>
              </div>
              <div class="fragment blue-box" data-fragment-index="2">
                <ul>
                  <li>Main loop checks the flag in some (not all!) bytecode ops</li>
                  <li>If the flag is set, raises <code>KeyboardInterrupt</code></li>
                </ul>
              </div>
            </div>
          </div>
          <p class="footnote">
            <sup>1</sup> Except on Windows</p>
          <aside class="notes">
            So to reiterate, control-C causes a “signal” to be
            delivered to CPython.  At the time of delivery, the
            interpreter just sets a flag.  Then it waits to get back
            to a point where it’s actually safe to raise a
            Python-level exception and unwind the Python call stack.
            <p>
              There’s always a safe point at the beginning of certain
              bytecode instructions.  If you look at bytecodes.c, it’s
              the ops that include the “check_periodic” component.
            <p>
              As long as we’re only running the code of CPython
              itself, it never takes very long to get to one of those
              safe points.  But compiled code extensions might
              introduce large delays, as we’ve seen.  Next let’s look
              at why that is.
          </aside>
        </section>
        <section>
          <h2>What NumPy isn’t doing</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-python"
><span class="h-keyword">def</span> <span class="h-defun">f</span><span class="h-delim">(</span><span class="h-variable">rng</span><span class="h-delim">,</span> <span class="h-variable">out</span><span class="h-delim">):</span>
    <span class="h-keyword">for</span> <span class="h-variable">i</span> <span class="h-operator-word">in</span> <span class="h-name h-builtin">range</span><span class="h-delim">(</span><span class="h-name h-builtin">len</span><span class="h-delim">(</span><span class="h-name">out</span><span class="h-delim">)):</span>
        <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">rng</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-delim">()</span>
</pre>
              <pre class="fragment fade-up language-pybytecode" data-fragment-index="1"
> <span class="h-delim">[</span><span class="h-label">42</span><span class="h-delim">]</span>  <span class="h-opcode">FOR_ITER</span>        <span class="h-delim">to [</span><span class="h-label">96</span><span class="h-delim">]</span>
       <span class="h-opcode">STORE_FAST</span>       <span class="h-delim">1 (</span>i<span class="h-delim">)</span>
       <span class="h-opcode">LOAD_FAST</span>        <span class="h-delim">2 (</span>rng<span class="h-delim">)</span>
       <span class="h-opcode">LOAD_ATTR</span>        <span class="h-delim">5 (</span>NULL|self + random<span class="h-delim">)</span>
       <span class="h-opcode">CALL</span>             0
       <span class="h-opcode">LOAD_FAST</span>        <span class="h-delim">0 (</span>out<span class="h-delim">)</span>
       <span class="h-opcode">LOAD_FAST</span>        <span class="h-delim">1 (</span>i<span class="h-delim">)</span>
       <span class="h-opcode">STORE_SUBSCR</span>
       <span class="h-opcode h-recur">JUMP_BACKWARD</span>   <span class="h-delim">to [</span><span class="h-label">42</span><span class="h-delim">]</span>
 <span class="h-delim">[</span><span class="h-label">96</span><span class="h-delim">]</span>  <span class="h-opcode">END_FOR</span>
</pre>
            </div>
            <div class="sidebyside-2">
              <pre class="language-c"
><span class="h-keyword h-type"><span class="fragment custom delete" data-fragment-index="3">void</span><span class="fragment custom insert" data-fragment-index="3">int</span></span>
<span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t *</span><span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">npy_intp</span> <span class="h-variable">cnt</span><span class="h-delim">,</span> <span class="h-keyword h-type">double</span> <span class="h-type">*</span><span class="h-variable">out</span><span class="h-delim">)</span>
<span class="h-delim">{</span>
  <span class="h-type">npy_intp</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">cnt</span><span class="h-delim">;</span> <span class="h-name">i</span><span class="h-operator">++</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span>
    <span class="fragment custom insert" data-fragment-index="3"><span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">PyErr_CheckSignals</span><span class="h-delim">())</span></span>
    <span class="fragment custom insert" data-fragment-index="3">  <span class="h-keyword">return</span> <span class="h-number h-integer">-1</span><span class="h-delim">;</span></span>
  <span class="h-delim">}</span>
  <span class="fragment custom insert" data-fragment-index="3"><span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span></span>
<span class="h-delim">}</span>
</pre>
              <pre class="fragment fade-up language-asm" data-fragment-index="2"
><span class="h-label">.L3</span><span class="h-delim">:</span>
    <span class="h-opcode">mov</span>    <span class="h-variable">rdi</span><span class="h-delim">,</span> <span class="h-variable">r12</span>
    <span class="h-opcode">call</span>   <span class="h-name h-function">next_double</span>
    <span class="h-opcode">movsd</span>  qword <span class="h-delim">[</span><span class="h-variable">r13</span>+<span class="h-variable">rbx</span>*<span class="h-number">8</span><span class="h-delim">],</span> <span class="h-variable">xmm0</span>
    <span class="h-opcode">add</span>    <span class="h-variable">rbx</span><span class="h-delim">,</span> <span class="h-number h-integer">1</span>
    <span class="h-opcode">cmp</span>    <span class="h-variable">rbp</span><span class="h-delim">,</span> <span class="h-variable">rbx</span>
    <span class="h-opcode h-recur">jne</span>    <span class="h-label">.L3</span>
</pre>
            </div>
          </div>
          <aside class="notes">
            The delay is because of something NumPy <em>isn’t</em>
            doing.
            <p>
              On the right here, we have the inner loop that executes
              when you run <code>numpy.random(n)</code>.  This is C,
              so there’s no methods and not really any arrays either,
              so on the left I show <em>basically</em> equivalent
              Python.  They’re doing the same thing.
            <p>
              Or are they? Here’s the bytecode disassembly for the
              Python loop.  It’s calling the random number generator,
              and storing the result to index i of the out array, and
              then doing it again for the next value of i… but see the
              highlighted bytecode instruction, JUMP_BACKWARD?  That’s
              one of the instructions that checks the flag.  So if you
              hit control-C while this function is running, it will
              stop after no more than one more iteration.
            <p>
              Now here’s the x86 <em>machine</em> disassembly for the
              C loop.  Same structure, different details, mostly doing
              the same thing.  But the JUMP_BACKWARD equivalent, jne
              down there at the bottom, it doesn’t check the flag.
              How could it?  Intel and AMD’s hardware engineers don’t
              design details of CPython into their CPUs!
            <p>
              If we want our compiled code extensions to check that
              flag, we need to write explicit code to do it.
            <p>
              This is the most basic form of the change we’d need to
              make to this function.
          </aside>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <ul>
            <li>Abstractly simple
              <ul>
                <li>Call <code>PyErr_CheckSignals</code> periodically</li>
                <li>If it returns −1, treat as failure; abandon work, return</li>
              </ul></li>
          </ul>
          <aside class="notes">
            Abstractly, it’s simple.
            <p>
              There’s a C-API function that checks the
              flag. PyErr_CheckSignals.
            <p>
              “All” you have to do is call it periodically, and if it
              returns minus one, treat that as a failure, with an
              exception already set for you.  Abandon your work and
              propagate the error return all the way out of the
              extension.
            <p>
              But of course it’s not that simple.
          </aside>
        </section>
        <section>
          <blockquote class="long-quote">
            <h2><code class="language-c"><span class="h-type h-keyword">int</span> <span class="h-defun">PyErr_CheckSignals</span><span class="h-delim">()</span></code></h2>
            <p><em>Part of the Stable ABI.</em></p>
            <p>This function interacts with Python’s signal handling.</p>
            <p>If the function is called from the main thread and under the main Python interpreter, it checks whether a
              signal has been sent to the processes and if so, invokes the corresponding signal handler. If the signal
              module is supported, this can invoke a signal handler written in Python.</p>
            <p>The function attempts to handle all pending signals, and then returns 0. However, if a Python signal
              handler raises an exception, the error indicator is set and the function returns −1 immediately (such
              that other pending signals may not have been handled yet: they will be on the next
              <code>PyErr_CheckSignals()</code> invocation).</p>
            <p>If the function is called from a non-main thread, or under a non-main Python interpreter, it does nothing
              and returns 0.</p>
            <p class="fragment highlight-green">
              This function can be called by long-running C code that wants to be interruptible by user requests (such
              as by pressing Ctrl-C).</p>
            <p>Note: The default Python signal handler for <code>SIGINT</code> raises the <code>KeyboardInterrupt</code>
              exception.</p>
          </blockquote>
          <aside class="notes">
            The first problem I want to highlight is: how are we,
            extension authors, to know we need to do that?
            <p>
              Here’s the documentation for PyErr_CheckSignals.
              It’s a big wall of text.  I’m gonna highlight the
              crucial sentence:
            <p>
              “This function can be called by long-running code that
              wants to be interruptible.”
              That doesn’t sound nearly as important as it is.
              I might have written something like “Long-running code
              <em>needs</em> to call this function frequently in order
              for the interpreter to be responsive to user
              interrupts.”
            <p>
              And I’d have made it the first sentence!
            <p>
              Not to mention, before you can read this wall of text
              and realize its implications, you need to <em>find</em>
              it.
            <p>
              It’s buried in the “signal handling” section of the
              exception-handling chapter of the
              C-API <em>reference</em> manual.  The “extending and
              embedding” guide doesn’t mention it at all.
          </aside>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <ul>
            <li class="pastbullet">Abstractly simple
              <ul>
                <li>Call <code>PyErr_CheckSignals</code> periodically</li>
                <li>If it returns −1, treat as failure; abandon work, return</li>
              </ul></li>
            <li>Not obvious from docs that you <em>need</em> to do that</li>
          </ul>
          <aside class="notes">
            Let’s keep a list of reasons why extensions aren’t
            interruptible right now.  Item: not obvious from docs that
            you need to do this.
          </aside>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-c"
><span class="h-keyword h-type"><del>void</del></span>
<span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t *</span><span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">npy_intp</span> <span class="h-variable">cnt</span><span class="h-delim">,</span> <span class="h-keyword h-type">double</span> <span class="h-type">*</span><span class="h-variable">out</span><span class="h-delim">)</span>
<span class="h-delim">{</span>
  <span class="h-type">npy_intp</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">cnt</span><span class="h-delim">;</span> <span class="h-name">i</span><span class="h-operator">++</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span>


  <span class="h-delim">}</span>

<span class="h-delim">}</span></pre>
            </div>
            <div class="sidebyside-2">
              <pre data-line-numbers="1,7,8,10" class="language-c"
><span class="h-keyword h-type"><ins>int</ins></span>
<span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t *</span><span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">npy_intp</span> <span class="h-variable">cnt</span><span class="h-delim">,</span> <span class="h-keyword h-type">double</span> <span class="h-type">*</span><span class="h-variable">out</span><span class="h-delim">)</span>
<span class="h-delim">{</span>
  <span class="h-type">npy_intp</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">cnt</span><span class="h-delim">;</span> <span class="h-name">i</span><span class="h-operator">++</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span>
    <ins><span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">PyErr_CheckSignals</span><span class="h-delim">())</span></ins>
    <ins>  <span class="h-keyword">return</span> <span class="h-number h-integer">-1</span><span class="h-delim">;</span></ins>
  <span class="h-delim">}</span>
  <ins><span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span></ins>
<span class="h-delim">}</span></pre>
            </div>
          </div>
          <aside class="notes">
            Now let’s look again at the code changes, side by side to
            make it easier to think about.  This is just one function.
            It didn’t used to be able to fail.  I had to change the
            return type from void to int just so it could return the error
            indication from PyErr_CheckSignals.  All its callers need
            to change to match, and so on, all the way up the call
            stack till we get back to Python core.
          </aside>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <ul>
            <li class="pastbullet">Abstractly simple
              <ul>
                <li>Call <code>PyErr_CheckSignals</code> periodically</li>
                <li>If it returns −1, treat as failure; abandon work, return</li>
              </ul></li>
            <li class="pastbullet">Not obvious from docs that you <em>need</em> to do that</li>
            <li>Have to decide <em>where</em> and <em>how often</em> to do that</li>
            <li>Must propagate the −1 return all the way up your call chain</li>
          </ul>
          <aside class="notes">
            Item: Have to find all the places in your extension where
            it can loop for a long time, add the calls, and propagate
            the failure returns back out.
            <p>
            Note “how often.”  I’m going to come back to that.
          </aside>
        </section>
        <section>
          <blockquote class="long-quote">
            <h2><code class="language-c"><span class="h-type h-keyword">int</span> <span class="h-defun">PyErr_CheckSignals</span><span class="h-delim">()</span></code></h2>
            <p><em>Part of the Stable ABI.</em></p>
            <p>This function interacts with Python’s signal handling.</p>
            <p>If the function is called from the main thread and under the main Python interpreter, it checks whether a
              signal has been sent to the processes and if so, invokes the corresponding signal handler. <span class=
              "fragment highlight-red">If the signal module is supported, this can invoke a signal handler written in
              Python.</span></p>
            <p>The function attempts to handle all pending signals, and then returns 0. However, if a Python signal
              handler raises an exception, the error indicator is set and the function returns −1 immediately (such
              that other pending signals may not have been handled yet: they will be on the next
              <code>PyErr_CheckSignals()</code> invocation).</p>
            <p>If the function is called from a non-main thread, or under a non-main Python interpreter, it does nothing
              and returns 0.</p>
            <p class="highlighted-green">
              This function can be called by long-running C code that wants to be interruptible by user requests (such
              as by pressing Ctrl-C).</p>
            <p>Note: The default Python signal handler for <code>SIGINT</code> raises the <code>KeyboardInterrupt</code>
              exception.</p>
          </blockquote>
          <aside class="notes">
            Here’s that wall of text again… because there’s another
            sentence in here that’s very important.
            <p>
              This one.
            <p>
              “If the signal module is supported, this can invoke a
              handler written in Python.”
            <p>
              PyErr_CheckSignals might run arbitrary Python code
              before returning to you.
          </aside>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-c"
><span class="h-keyword h-type">int</span>
<span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t *</span><span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">npy_intp</span> <span class="h-variable">cnt</span><span class="h-delim">,</span> <span class="h-keyword h-type">double</span> <span class="h-type">*</span><span class="h-variable">out</span><span class="h-delim">)</span>
<span class="h-delim">{</span>


  <span class="h-type">npy_intp</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">cnt</span><span class="h-delim">;</span> <span class="h-name">i</span><span class="h-operator">++</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span>
    <span class="fragment custom delete" data-fragment-index="1"><span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">PyErr_CheckSignals</span><span class="h-delim">())</span></span>
    <span class="fragment custom delete" data-fragment-index="1">  <span class="h-keyword">return</span> <span class="h-number h-integer">-1</span><span class="h-delim">;</span></span>


  <span class="h-delim">}</span>
  <span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span>
<span class="h-delim">}</span></pre>
            </div>
            <div class="sidebyside-2">
              <pre class="language-c fragment" data-fragment-index="1"
><span class="h-keyword h-type">int</span>
<span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t *</span><span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">npy_intp</span> <span class="h-variable">cnt</span><span class="h-delim">,</span> <span class="h-keyword h-type">double</span> <span class="h-type">*</span><span class="h-variable">out</span><span class="h-delim">)</span>
<span class="h-delim">{</span>
  <ins><span class="h-type">PyGILState_STATE</span> <span class="h-variable">st</span><span class="h-delim">;</span></ins>
  <ins><span class="h-keyword h-type">int</span> <span class="h-variable">err</span><span class="h-delim">;</span></ins>
  <span class="h-type">npy_intp</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">cnt</span><span class="h-delim">;</span> <span class="h-name">i</span><span class="h-operator">++</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span>
    <ins><span class="h-name">st</span> <span class="h-operator">=</span> <span class="h-name">PyGILState_Ensure</span><span class="h-delim">();</span></ins>
    <ins><span class="h-name">err</span> <span class="h-operator">=</span> <span class="h-name">PyErr_CheckSignals</span><span class="h-delim">();</span></ins>
    <ins><span class="h-name">PyGILState_Release</span><span class="h-delim">(</span><span class="h-name">st</span><span class="h-delim">);</span></ins>
    <ins><span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">err</span><span class="h-delim">)</span> <span class="h-keyword">return</span> <span class="h-name">err</span><span class="h-delim">;</span></ins>
  <span class="h-delim">}</span>
  <span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span>
<span class="h-delim">}</span>


</pre>
            </div>
          </div>
          <aside class="notes">
            And that means the simple logic I showed you earlier is
            wrong, because NumPy likes to drop the global interpreter
            lock when it’s running a loop like this.
            <p>
              We need this change instead.  This function was called
              without the GIL, so it needs to use PyGILState_Ensure
              to <em>reclaim</em> the GIL for just long enough to
              call PyErr_CheckSignals, and then release it again.
            <p>
              By the way: Raise your hand if you knew about
              PyGILState_Ensure and _Release before you saw this
              slide.
            <p>
              Yeah, those are buried pretty deep in the manual, too.
          </aside>
        </section>
        <section>
          <h2>Why isn’t it doing that?</h2>
          <ul>
            <li class="pastbullet">Abstractly simple
              <ul>
                <li>Call <code>PyErr_CheckSignals</code> periodically</li>
                <li>If it returns −1, treat as failure; abandon work, return</li>
              </ul></li>
            <li class="pastbullet">Not obvious from docs that you <em>need</em> to do that</li>
            <li class="pastbullet">Have to decide <em>where</em> and <em>how often</em> to do that</li>
            <li class="pastbullet">Must propagate the −1 return all the way up your call chain</li>
            <li>
              <code>PyErr_CheckSignals</code> can run arbitrary Python code
              <ul>
                <li>Needs to be <em>safe</em> to run arbitrary Python</li>
                <li>May need to reclaim the GIL (expensive)</li>
              </ul></li>
          </ul>
          <aside class="notes">
            Item. PyErr_CheckSignals can run arbitrary Python.  Can
            only call it when safe.  In particular, may need to
            reclaim the GIL.
            <p>
              Remember I said we’d come back to “how often”?
              Now is the time, because taking and releasing a big
              mutex like the GIL is expensive.  Let’s find out just
              how expensive.
          </aside>
        </section>
        <section>
          <h2>A more complicated example</h2>
          <div class="r-stack">
            <object class="figure" data="kfft-example-1.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data="kfft-example-2.svg" type="image/svg+xml"></object>
          </div>
          <aside class="notes">
            If we set out to fix this bug for real, we wouldn’t add
            PyErr_CheckSignals calls on every single iteration of an
            innermost loop like the one I’ve been showing you, that’d
            be terrible for throughput.  You’d want to do it only
            every few tens of thousands of iterations or so.  Also,
            “fill an array with a zillion random numbers” isn’t very
            challenging in terms of the changes we need to make.  So
            here’s a more interesting and realistic benchmark: the
            core of the simplest fast Fourier transform implementation
            I could find.  Originally written by a fellow name of Mark
            Borgerding.
            <p>
              If you’re here today, Mark Borgerding, please stand up
              for a moment.
            <p>
              I hacked up a wrapper of this code as a Python module,
              and I made it so it can test lots of different cases;
              most importantly, I can benchmark it with the outermost
              caller of this function <em>either</em> having released
              the GIL or held onto it.
            <p>
              Outermost, because this function is recursive.  I’ve
              highlighted the recursive call, in yellow, right in the
              middle.  One of the innermost loops of the FFT is right
              above, the <code>if m == 1</code> case, and the others
              are in the functions called down at the bottom, kf_bfly2
              and 4.
            <p>
              It’d be too costly to call PyErr_CheckSignals on every
              trip through those innermost loops.  For this algorithm
              I decided it ought to be good enough to check here and
              here, after each pass over the array.
            <p>
              You can call PyGILState_Ensure whether or not you have
              released the GIL; it does almost no work if you haven’t.
              As far as I can tell this is the <em>only</em> way to
              reclaim the GIL that doesn’t deadlock if you call it
              when you already hold the GIL.
          </aside>
        </section>
        <section>
          <h2>Cost of checking for signals</h2>
          <div class="r-stack">
            <object class="figure" data="cost-check-sp-1.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data="cost-check-sp-2.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data="cost-check-sp-3.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data="cost-check-sp-4.svg" type="image/svg+xml"></object>
          </div>
          <aside class="notes">
            I wrote my test module so I can benchmark the FFT with or
            without signal checks, and with or without releasing the
            GIL around the whole computation.
            <p>
              Without any signal checks, and without releasing the GIL,
              I measured this nice linear relationship between FFT problem
              size and execution time.  Note both axes are on a log scale.
            <p>
              Releasing the GIL doesn’t add any measurable overhead.
              All benchmarks were run single-threaded, incidentally,
              because parallel benchmarks added way too much noise.
              But the GIL was still a real mutex, not a stub.
            <p>
              If we don’t drop the GIL, enabling signal checks is
              pretty cheap.  No signals actually sent, to be clear,
              we’re measuring how much it costs to have the checks
              even when they have nothing to do, like they would
              most of the time.
            <p>
              But if we do drop the GIL, suddenly the signal checks
              are a lot more expensive.
          </aside>
        </section>
        <section>
          <div class="r-stack">
            <h2>Cost of checking for signals</h2>
          </div>
          <div class="r-stack">
            <object class="figure" data="cost-per-sample-1.svg" type="image/svg+xml"></object>
          </div>
          <aside class="notes">
            It’s hard to compare the slopes of lines by eye, so this
            plot shows what we get if we divide out the problem size.
            The recursive structure of the FFT implementation means
            there’s still an <em>effect</em> of the problem size, but
            we can see the effect of turning on checks, more easily.
            If we hold the GIL over the whole operation it’s cheap,
            but if we release the GIL, so we have to take it back to
            call PyErr_CheckSignals, we go from a few tens of
            nanoseconds per sample to several hundred.
            <p>
              And remember that I took care not to add calls to
              PyErr_CheckSignals after every iteration of the
              innermost loops.  If I’d benchmarked the changes to
              NumPy’s random number fill function that I showed you
              earlier, those costs would be worse.
          </aside>
        </section>
        <section>
          <h2>What if we didn’t check every time?</h2>
          <div class="r-stack">
            <object class="figure" data="kfft-example-1.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment fade-out" data-fragment-index="1"
                    data="kfft-example-2.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment fade-in" data-fragment-index="1"
                    data="kfft-example-3.svg" type="image/svg+xml"></object>
          </div>
          <aside class="notes">
            The obvious thing to do about this is not check as
            often.  As long as we react within like a millisecond of
            the signal being delivered, user responsiveness will be
            plenty good enough.
            <p>
              We already aren’t checking after every iteration;
              but what if we literally look at the clock?  Like this.
              Ask the OS if at least a millisecond has gone by since
              the last time we called PyErr_CheckSignals; only call
              it, and only reclaim the GIL, if it has.
          </aside>
        </section>
        <section>
          <div class="r-stack">
            <h2 class="fragment fade-out" data-fragment-index="1">What if we didn’t check every time?</h2>
            <h2 class="fragment fade-in" data-fragment-index="1">Claw back more speed with coarse clock</h2>
          </div>
          <div class="r-stack">
            <object class="figure" data="cost-per-sample-1.svg" type="image/svg+xml"></object>
            <object class="figure-nobg" data="cost-per-sample-2.svg" type="image/svg+xml"></object>
            <object class="figure-nobg fragment" data-fragment-index="1"
                    data="cost-per-sample-3.svg" type="image/svg+xml"></object>
          </div>
          <aside class="notes">
            The third row of this plot shows what we get if we check
            only once a millisecond.  There’s still quite a bit of
            overhead but not nearly as much as “check whenever possible.”
            <p>
              CLOCK_MONOTONIC is high-precision and that means it has
              high overhead.  Some operating systems offer a “coarse”
              version that’s plenty good enough to tell us if a
              millisecond has gone by.  That version is efficient
              enough that the performance cost is barely measurable
              except for the biggest problem sizes.  And notice that
              “check every 1ms, coarse clock” with the
              GIL <em>released</em> is no more expensive than “check
              whenever possible” with the GIL <em>held</em>.
            <p>
              I haven’t tested the new free-threaded interpreter at
              all yet, by the way.  Sorry about that.
          </aside>
        </section>
        <section>
          <h2>Longer intervals don’t help</h2>
          <div class="r-stack">
          <object class="figure" data="cost-by-interval-median.svg" type="image/svg+xml"></object>
          </div>
          <aside class="notes">
            You might be thinking, 1 millisecond is still awful short.
            But it’s long enough to the CPU that the lion’s share of
            the remaining overhead is <em>the overhead of looking at
            the clock</em>, and we can’t make that any smaller by
            increasing the interval between calls to
            PyErr_CheckSignals.
          </aside>
        </section>
        <section>
          <h2>Recap</h2>
          <ul>
            <li>CPython interpreter cannot raise
              <code>KeyboardInterrupt</code> directly from its
              C-level signal handler
              <ul>
                <li>Must return to main interpreter loop before raising exceptions</li>
                <li>Prompt return needs cooperation from compiled-code extensions</li>
              </ul>
            </li>
            <li>Many extensions do not cooperate
              <ul>
                <li>Need to do this has not been well advertised</li>
                <li>Retrofit requires finicky code changes</li>
                <li>Substantial runtime costs</li>
              </ul>
            </li>
          </ul>
          <aside class="notes">
            Recap: The CPython interpreter cannot raise
            KeyboardInterrupt directly from its C-level signal
            handler, it must return to its main loop first.  To do
            that promptly when the signal interrupted a compiled-code
            extension, requires cooperation from that extension.
            <p>
              Many extensions don’t cooperate, and we’ve just seen
              why: it’s not well advertised that you need to do this,
              it requires finicky code changes, and it has substantial
              runtime costs if you’re not careful about it.
          </aside>
        </section>
        <section>
          <h2>Short term recommendation</h2>
          <pre class="language-c"
><span class="h-keyword h-type">int</span> <span class="h-defun">CheckSignalsOftenEnough</span><span class="h-delim">(</span><span class="h-keyword h-type">void</span><span class="h-delim">)</span> <span class="h-delim">{</span>
  <span class="h-keyword">static</span> <span class="h-keyword h-type">struct</span> <span class="h-type">timespec</span> <span class="h-variable">last_check</span> <span class="h-operator">=</span> <span class="h-delim">{</span> <span class="h-number h-integer">0</span><span class="h-delim">,</span> <span class="h-number h-integer">0</span> <span class="h-delim">};</span>
  <span class="h-keyword h-type">struct</span> <span class="h-type">timespec</span> <span class="h-variable">now</span><span class="h-delim">;</span>
  <span class="h-name">clock_gettime</span><span class="h-delim">(</span><span class="h-name">CLOCK_MONOTONIC_COARSE</span><span class="h-delim">,</span> <span class="h-operator">&amp;</span><span class="h-name">now</span><span class="h-delim">);</span>

  <span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">timespec_difference_at_least</span><span class="h-delim">(</span><span class="h-operator">&amp;</span><span class="h-name">now</span><span class="h-delim">,</span> <span class="h-operator">&amp;</span><span class="h-name">last_check</span><span class="h-delim">,</span> <span class="h-name">ONE_MS_IN_NS</span><span class="h-delim">))</span> <span class="h-delim">{</span>
    <span class="h-name">last_check</span> <span class="h-operator">=</span> <span class="h-name">now</span><span class="h-delim">;</span>
    <span class="h-type">PyGILState_STATE</span> <span class="h-variable">st</span> <span class="h-operator">=</span> <span class="h-name">PyGILState_Ensure</span><span class="h-delim">();</span>
    <span class="h-keyword h-type">int</span> <span class="h-name">err</span> <span class="h-operator">=</span> <span class="h-name">PyErr_CheckSignals</span><span class="h-delim">();</span>
    <span class="h-name">PyGILState_Release</span><span class="h-delim">(</span><span class="h-name">st</span><span class="h-delim">);</span>
    <span class="h-keyword">return</span> <span class="h-name">err</span><span class="h-delim">;</span>
  <span class="h-delim">}</span>
  <span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span>
<span class="h-delim">}</span></pre>
          <p class="footnote">
            Full version:
            <a href="https://github.com/MillionConcepts/cpython-ext-ctrl-c/blob/main/pycon-2025/CheckSignalsOftenEnough.c"
               ><code>https://github.com/MillionConcepts/cpython-ext-ctrl-c/blob/main/pycon-2025/CheckSignalsOftenEnough.c</code></a>
          </p>
          <aside class="notes">
            Here’s my short-term recommendation.  Take the code from
            the link at the bottom of the slide and paste it into your
            extension.  You may need to tweak for portability, I’ve only
            tested it on Linux and FreeBSD with gcc and clang.
            <p>
              Call <code>CheckSignalsOftenEnough</code> at appropriate
              moments.  You still have to figure out where to do that,
              and how to propagate the failure back out of your
              extension, but it takes care of looking at the clock and
              being GIL-safe for you.
            <p>
              It doesn’t take care of any other reason why it might
              not be safe to run arbitrary Python at the point where
              you inserted the call, though, like if you’re cutting
              corners on reference counting.
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul class="fragment" data-fragment-index="1"><li>Improve core documentation
              <ul>
                <li>Highlight need to call <code>PyErr_CheckSignals</code> regularly</li>
                <li>Explain how to do so safely</li>
                <li>Explain how to do so efficiently</li>
              </ul>
          </li></ul>
          <div class="zany-o-meter fragment" data-fragment-index="1"
               >zaniness: <img src="z/librarian.svg" height="80"></div>
          <aside class="notes">
            <p>
              So. This helps, but can we do better?
            <p>
              I have some ideas, which I will now tell you,
              in ascending order of zaniness.
            <p>
            First off, let’s improve the documentation so people know
            they need to do this and they know how to do it safely and
            efficiently.  I think it deserves its own section in the
            “extending and embedding” guide.
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Don’t require GIL to call <code>PyErr_CheckSignals</code>
              <ul>
                <li>Cost of frequent checks is mostly cost of locking</li>
                <li>Signal flag is an atomic variable! Don’t need GIL to test it</li>
                <li class="fragment fade-up" data-fragment-index="1"
                    >Have <code>PyErr_CheckSignals</code> reclaim GIL
                     itself, before running Python signal handlers,
                  <em>only if flag is set</em></li>
                <li class="fragment fade-up" data-fragment-index="1"
                    >(Still needs to be <em>safe</em> to take GIL at any callsite)</li>
                <li class="fragment fade-up" data-fragment-index="1"
                    >Proposed for Python 3.14: <a href="https://github.com/python/cpython/issues/133465">gh-133465</a></li>
              </ul>
          </li></ul>
          <div class="zany-o-meter"
               >zaniness: <img src="z/hacker-python.svg" height="80"></div>
          <aside class="notes">
            Maybe we could push the PyGILState_Ensure calls down into
            PyErr_CheckSignals, making it safe to call with or without
            the GIL, as long as it’s safe to take the GIL at the
            callsite?  The signal flag itself is an atomic variable,
            so PyErr_CheckSignals could test the flag without taking
            the GIL, and only take the GIL if the flag is set.
            <p>
              This would eliminate any need to look at the clock and
              space out the calls.  CheckSignalsOftenEnough could just
              be PyErr_CheckSignals.  You’d still want to avoid
              calling it on every single iteration, though, if only
              because that would block the compiler from vectorizing
              your loops.
            <p>
              I have written a PR for Python 3.14 that does this.
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Make Cython, Numba, and similar tools insert checks for you</li></ul>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <pre class="language-cython"
><span class="h-keyword">cdef</span> <span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t</span> <span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">double</span> <span class="h-delim">[:]</span> <span class="h-variable">out</span><span class="h-delim">,</span>
<span class="h-delim">)</span> <span class="h-keyword">nogil</span><span class="h-delim">:</span>
    <span class="h-keyword">for</span> <span class="h-variable">i</span> <span class="h-operator-word">in</span> <span class="h-name h-builtin">range</span><span class="h-delim">(</span><span class="h-name h-builtin">len</span><span class="h-delim">(</span><span class="h-name">out</span><span class="h-delim">)):</span>
        <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">)</span></pre>
            </div>
            <div class="sidebyside-2">
              <pre class="language-c fragment" data-fragment-index="1"
><span class="h-keyword h-type">int</span> <span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-type">bitgen_t</span> <span class="h-variable">rng</span><span class="h-delim">,</span>
    <span class="h-type">__Pyx_memviewslice</span> <span class="h-variable">out</span>
<span class="h-delim">)</span> <span class="h-delim">{</span>
  <span class="h-type">Py_ssize_t</span> <span class="h-variable">i</span><span class="h-delim">;</span>
  <span class="h-type">Py_ssize_t</span> <span class="h-variable">len</span><span class="h-delim">;</span>
  <span class="h-name">len</span> <span class="h-operator">=</span> <span class="h-name">__Pyx_MemoryView_Len</span><span class="h-delim">(</span><span class="h-name">out</span><span class="h-delim">);</span>
  <span class="h-keyword">for</span> <span class="h-delim">(</span><span class="h-name">i</span> <span class="h-operator">=</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">&lt;</span> <span class="h-name">len</span><span class="h-delim">;</span> <span class="h-name">i</span> <span class="h-operator">+=</span> <span class="h-number h-integer">1</span><span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-operator">*</span><span class="h-delim">((</span><span class="h-keyword h-type">double</span> <span class="h-operator">*</span><span class="h-delim">)</span>
      <span class="h-delim">((</span><span class="h-name">out</span><span class="h-delim">.</span><span class="h-name">data</span> <span class="h-operator">+</span>
        <span class="h-name">i</span> <span class="h-operator">*</span> <span class="h-name">out</span><span class="h-delim">.</span><span class="h-name">strides</span><span class="h-delim">[</span><span class="h-number h-integer">0</span><span class="h-delim">])))</span> <span class="h-operator">=</span>
      <span class="h-name">next_double</span><span class="h-delim">(</span><span class="h-name">rng</span><span class="h-delim">);</span>
    <span class="fragment custom insert" data-fragment-index="2"><span class="h-keyword">if</span> <span class="h-delim">(</span><span class="h-name">CheckSignalsOftenEnough</span><span class="h-delim">())</span></span>
    <span class="fragment custom insert" data-fragment-index="2">  <span class="h-keyword">return</span> <span class="h-number h-integer">-1</span><span class="h-delim">;</span></span>
  <span class="h-delim">}</span>
  <span class="h-keyword">return</span> <span class="h-number h-integer">0</span><span class="h-delim">;</span>
<span class="h-delim">}</span>

</pre>
            </div>
          </div>
          <div class="zany-o-meter"
               >zaniness: <img src="z/sane-scientist.svg" height="80"></div>
          <aside class="notes">
            Lots of NumPy is written in Cython.  Maybe the Cython
            compiler, and Numba, and so on, could insert the necessary
            calls for us?  Like this.  Or even better, make it happen
            only once every 16,384 iterations and avoid getting in the
            way of vectorization.
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>In tools like PyO3, model control-C as async cancellation</li></ul>
          <pre class="language-rust"
><span class="h-directive">#[pyfunction]</span>
<span class="h-keyword">async</span> <span class="h-keyword">fn</span> <span class="h-defun">random_standard_uniform_fill</span><span class="h-delim">(</span>
    <span class="h-directive">#[pyo3(cancel_handle)]</span> <span class="h-keyword">mut</span> <span class="h-variable">cancel</span><span class="h-delim">:</span> <span class="h-type">CancelHandle</span><span class="h-delim">,</span>
    <span class="h-variable">rng</span><span class="h-delim">:</span> <span class="h-type">BitGen</span><span class="h-delim">,</span>
    <span class="h-variable">out</span><span class="h-delim">:</span> <span class="h-keyword h-type">&amp;mut</span> <span class="h-type">f64[]</span><span class="h-delim">,</span>
<span class="h-delim">)</span> <span class="h-delim">{</span>
    <span class="h-name">futures</span><span class="h-delim">::</span><span class="h-name">select</span><span class="h-operator">!</span> <span class="h-delim">{</span>
        <span class="h-name">cancel</span><span class="h-delim">.</span><span class="h-name">cancelled</span><span class="h-delim">.</span><span class="h-name">fuse</span><span class="h-delim">()</span> <span class="h-operator">=&gt;</span> <span class="h-delim">{},</span>
        <span class="h-name">_</span> <span class="h-operator">=&gt;</span> <span class="h-delim">{</span>
            <span class="h-keyword">for</span> <span class="h-variable">i</span> <span class="h-keyword">in</span> <span class="h-number h-integer">0</span><span class="h-operator">..</span><span class="h-name">out</span><span class="h-delim">.</span><span class="h-name">len</span><span class="h-delim">()</span> <span class="h-delim">{</span>
                <span class="h-name">out</span><span class="h-delim">[</span><span class="h-name">i</span><span class="h-delim">]</span> <span class="h-operator">=</span> <span class="h-name">rng</span><span class="h-delim">.</span><span class="h-name">next_double</span><span class="h-delim">();</span>
            <span class="h-delim">}</span>
        <span class="h-delim">}</span>
    <span class="h-delim">}</span>
<span class="h-delim">}</span>
</pre>
          <div class="zany-o-meter"
               >zaniness: <img src="z/lobster.svg" height="80"></div>
          <aside class="notes">
            If you’re writing your compiled code by hand, a library
            can’t help you very much… or can it?  Rust has cancellable
            asynchronous functions.  Maybe PyO3 could map control-C
            onto asynchronous cancellation.
            <p>
              The code on this slide is almost certainly wrong, by the
              way.  I kludged it together from fragments of the PyO3
              manual and didn’t test it at all.  Don’t copy and paste
              this one.
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <div class="sidebyside">
            <div class="sidebyside-1">
              <ul>
                <li>Turn Python into a shell-structured language</li>
                <li>Evaluate top level steps in a <em>subprocess</em></li>
              </ul>
            </div>
            <div class="sidebyside-2">
              <pre class="language-python-repl"
><span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword h-namespace">import</span> <span class="h-name h-namespace">numpy</span> <span class="h-keyword">as</span> <span class="h-name h-namespace">np</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-variable">rng</span> <span class="h-operator">=</span> <span class="h-name">np</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-operator">.</span><span class="h-name">default_rng</span><span class="h-delim">()</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-keyword">def</span> <span class="h-defun">g</span><span class="h-delim">(</span><span class="h-variable">n</span><span class="h-operator">=</span><span class="h-number h-integer">1000000000</span><span class="h-delim">):</span>
<span class="h-prompt">... </span>    <span class="h-keyword">return</span> <span class="h-name">rng</span><span class="h-operator">.</span><span class="h-name">random</span><span class="h-delim">(</span><span class="h-name">n</span><span class="h-delim">)</span>
<span class="h-prompt">...</span>
<span class="h-prompt">&gt;&gt;&gt; </span><span class="h-name">g</span><span class="h-delim">()</span></pre>
            </div>
          </div>
          <ul>
            <li>Pass the result back via shared memory</li>
            <li>Let the subprocess die on SIGINT</li>
            <li>(This is why the Unix shell doesn’t have the same problem)</li>
          </ul>
          <div class="zany-o-meter"
               >zaniness: <img src="z/dragon-head.svg" height="80"></div>
          <aside class="notes">
            If you’re an old Unix beard like me, you may have been
            thinking, as we went along, “how come the shell doesn’t
            have this problem?”  The <code>sort</code> utility
            probably doesn’t have any special handling for control-C
            and yet, when you control-C a pipeline with sort in it, it
            stops immediately.
            <p>
              The answer is, subprocesses.
            <p>
              Because (we presume) the sort process <em>doesn’t</em>
              have a handler for SIGINT, instead of “delivering” the
              signal the kernel just kills off the process, and the
              shell gets control back immediately.
            <p>
              We could restructure the CPython virtual machine to work
              the same way.  It’d be a huge change … but it would mean
              that we <em>don’t</em> have to add these checks to every
              compiled code extension on PyPI!
          </aside>
        </section>
        <section>
          <h2>How can we make this better?</h2>
          <ul><li>Brainstorming time!
              <ul>
                <li>Call out your ideas</li>
                <li>Or ask a question</li>
                <li>One sentence per person</li>
              </ul>
          </li></ul>
          <aside class="notes">
            That was the zaniest of my ideas.  Now I’d like to hear yours.
            Call ’em out.  One sentence per person.  Or ask a question.
          </aside>
        </section>
        <section>
          <h2>Acknowledgments</h2>
          <ul class="long-list">
            <li><p>Slides, code samples, raw data,
              and analysis scripts may be found<br>
              at <a href="https://github.com/MillionConcepts/cpython-ext-ctrl-c"><code>https://github.com/MillionConcepts/cpython-ext-ctrl-c</code></a><br>
              or <a href="https://git.sr.ht/~zackw/cpython-ext-ctrl-c"><code>https://git.sr.ht/~zackw/cpython-ext-ctrl-c</code></a><br>
              and may be reused under Million Concepts’ usual 3-clause BSD license</p></li>
            <li><a href="https://github.com/mborgerding/kissfft">KISS FFT</a> originally written by Mark Borgerding</li>
            <li>Data visualization thanks to <a href="https://ggplot2.tidyverse.org/">ggplot2</a> and <a href="https://wilkelab.org/cowplot/">cowplot</a></li>
            <li>Graphics postprocessed to various degrees in <a href="https://inkscape.org/">Inkscape</a></li>
            <li>Slide deck rendered with <a href="https://revealjs.com/">reveal.js</a></li>
            <li>Fonts are <a href="https://github.com/polarsys/b612"><code>B612 Mono</code></a>, <a href="https://github.com/alerque/libertinus">Libertinus Sans</a>, and <a href="https://www.1001freefonts.com/quando.font"><span class="use-heading-font">Quando</span></a></li>
            <li>Financial support from <a href="https://science.nasa.gov/astrophysics/programs/research-programs/">NASA ADAP</a> grant 80NSSC21K1421</li>
            <li>Clip art used in the zaniness meter:
              <a href="https://openclipart.org/detail/317789/librarian-4b">1</a>
              <a href="https://openclipart.org/detail/279204/kawaii-hacker">2</a>
              <a href="https://openclipart.org/detail/232922/science-student-with-spiky-hair">3</a>
              <a href="https://openclipart.org/detail/263067/red-cartoon-lobster">4</a>
              <a href="https://openclipart.org/detail/217264/dragon-sketch">5</a>
            </li>
          </ul>
        </section>
      </div>
    </div>
    <script src="rjs/reveal.js"></script>
    <script src="rjs/plugin-notes.js"></script>
    <script src="rjs/init.js"></script>
  </body>
</html>
<!--
  -- Local Variables:
  -- sgml-basic-offset: 2;
  -- End:
  -->
